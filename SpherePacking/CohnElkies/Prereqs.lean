/-
Copyright (c) 2024 Sidharth Hariharan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sidharth Hariharan
-/
/-
## THIS FILE SHOULD EVENTUALLY BE REMOVED AND THE REFERENCES IN COHN-ELKIES MUST BE REPLACED WITH
## THE RIGHT ONES (NOT THE ONES FROM HERE). THIS FILE IS JUST A TEMPORARY SOLUTION TO MAKE THE
## COHN-ELKIES FILE WORK.
-/
import Mathlib.Algebra.Module.Zlattice.Basic
import Mathlib.Algebra.Module.Zlattice.Covolume
import Mathlib.Analysis.Fourier.FourierTransform
import Mathlib.Analysis.Distribution.FourierSchwartz
import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Topology.Algebra.InfiniteSum.Basic
import Mathlib.Analysis.Normed.Group.InfiniteSum
import SpherePacking.Basic.SpherePacking
import SpherePacking.Basic.PeriodicPacking
import SpherePacking.ForMathlib.InvPowSummability

open BigOperators Bornology

variable {d : ‚Ñï} [Fact (0 < d)]
variable (Œõ : AddSubgroup (EuclideanSpace ‚Ñù (Fin d))) [DiscreteTopology Œõ] [IsZlattice ‚Ñù Œõ]

noncomputable section Dual_Lattice

/-
This section defines the Dual Lattice of a Lattice. Taken from `SpherePacking/ForMathlib/Dual.lean`.
-/

def DualLattice : AddSubgroup (EuclideanSpace ‚Ñù (Fin d)) where
  carrier := { x | ‚àÄ l : Œõ, ‚àÉ n : ‚Ñ§, ‚ü™x, l‚ü´_‚Ñù = ‚Üën }
  zero_mem' := by
    simp only [Subtype.forall, Set.mem_setOf_eq, inner_zero_left]
    intro a _
    use 0
    rw [Int.cast_zero]
  add_mem' := by
    intros x y hx hy l
    obtain ‚ü®n, hn‚ü© := hx l
    obtain ‚ü®m, hm‚ü© := hy l
    use n + m
    simp only [inner_add_left, hn, hm, Int.cast_add]
  neg_mem' := by
    intros x hx l
    obtain ‚ü®n, hn‚ü© := hx l
    use -n
    simp only [inner_neg_left, hn, Int.cast_neg]

end Dual_Lattice

section Euclidean_Space

instance instNonemptyFin : Nonempty (Fin d) := by
  rw [‚Üê Fintype.card_pos_iff, Fintype.card_fin]
  exact Fact.out

-- noncomputable instance : DivisionCommMonoid ENNReal where
--   inv_inv := inv_inv
--   mul_inv_rev := sorry
--   inv_eq_of_mul := sorry
--   mul_comm := sorry


end Euclidean_Space

open scoped FourierTransform

open Complex Real

noncomputable section PSF_L

/-
This section defines the Poisson Summation Formual, Lattice Version (`PSF_L`). This is a direct
dependency of the Cohn-Elkies proof.
-/

-- Could this maybe become a `structure` with each field being a different condition?
def PSF_Conditions (f : EuclideanSpace ‚Ñù (Fin d) ‚Üí ‚ÑÇ) : Prop :=
  /-
    Mention here all the conditions we decide to impose functions on which to define the PSF-L.
    For example, this could be that they must be Schwartz (cf. blueprint) or admissible (cf. Cohn-
    Elkies). This is a placeholder for now, as is almost everything in this file.

    I think Schwartz is a good choice, because we can use the results in
    `Mathlib.Analysis.Distribution.FourierSchwartz` to conclude various things about the function.
  -/
  Summable f ‚àß
  sorry

theorem PSF_L {f : EuclideanSpace ‚Ñù (Fin d) ‚Üí ‚ÑÇ} (hf : PSF_Conditions f)
  (v : EuclideanSpace ‚Ñù (Fin d)) :
  ‚àë' ‚Ñì : Œõ, f (v + ‚Ñì) = (1 / Zlattice.covolume Œõ) * ‚àë' m : DualLattice Œõ, (ùìï f m) *
  exp (2 * œÄ * I * ‚ü™v, m‚ü´_‚Ñù) :=
  sorry

-- The version below is on the blueprint. I'm pretty sure it can be removed.
theorem PSF_L' {f : EuclideanSpace ‚Ñù (Fin d) ‚Üí ‚ÑÇ} (hf : PSF_Conditions f) :
  ‚àë' ‚Ñì : Œõ, f ‚Ñì = (1 / Zlattice.covolume Œõ) * ‚àë' m : DualLattice Œõ, (ùìï f m) := by
  have := PSF_L Œõ hf (0 : EuclideanSpace ‚Ñù (Fin d))
  simp only [zero_add, inner_zero_left, ofReal_zero, mul_zero, Complex.exp_zero, mul_one] at this
  exact this

namespace SchwartzMap

theorem PoissonSummation_Lattices (f : SchwartzMap (EuclideanSpace ‚Ñù (Fin d)) ‚ÑÇ)
  (v : EuclideanSpace ‚Ñù (Fin d)) : ‚àë' ‚Ñì : Œõ, f (v + ‚Ñì) = (1 / Zlattice.covolume Œõ) *
  ‚àë' m : DualLattice Œõ, (ùìï f m) * exp (2 * œÄ * I * ‚ü™v, m‚ü´_‚Ñù) := by
  sorry

-- theorem PoissonSummation_Lattices' (f : SchwartzMap (EuclideanSpace ‚Ñù (Fin d)) ‚ÑÇ) :
--   ‚àë' ‚Ñì : Œõ, f ‚Ñì = (1 / Zlattice.covolume Œõ) * ‚àë' m : DualLattice Œõ, (ùìï f m) := by
--   sorry

end SchwartzMap

end PSF_L

open scoped ENNReal
open SpherePacking Metric BigOperators Pointwise Filter MeasureTheory Zspan

section numReps_Related

noncomputable instance PeriodicSpherePacking.instFintypeNumReps'
  (S : PeriodicSpherePacking d) (hd : 0 < d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))} (hD_isBounded : IsBounded D) :
  Fintype ‚Üë(S.centers ‚à© D) := @Fintype.ofFinite _ <| aux4 S D hD_isBounded hd

noncomputable def PeriodicSpherePacking.numReps' (S : PeriodicSpherePacking d) (hd : 0 < d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))} (hD_isBounded : IsBounded D) : ‚Ñï :=
  letI := S.instFintypeNumReps' hd hD_isBounded
  Fintype.card ‚Üë(S.centers ‚à© D)

theorem PeriodicSpherePacking.numReps'_nonneg (S : PeriodicSpherePacking d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))} (hD_isBounded : IsBounded D) :
  0 ‚â§ S.numReps' Fact.out hD_isBounded := by
  letI := S.instFintypeNumReps' Fact.out hD_isBounded
  rw [PeriodicSpherePacking.numReps']
  exact Nat.zero_le (Fintype.card ‚Üë(S.centers ‚à© D))

theorem PeriodicSpherePacking.numReps_eq_numReps' (S : PeriodicSpherePacking d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))} (hD_isBounded : IsBounded D)
  (hD_unique_covers : ‚àÄ x, ‚àÉ! g : S.lattice, g +·µ• x ‚àà D) :
  S.numReps = S.numReps' Fact.out hD_isBounded := by
  letI := S.instFintypeNumReps' Fact.out hD_isBounded
  rw [PeriodicSpherePacking.numReps']
  rw [‚Üê S.card_centers_inter_isFundamentalDomain D hD_isBounded hD_unique_covers Fact.out]
  exact Set.toFinset_card (S.centers ‚à© D)

-- theorem PeriodicSpherePacking.numReps_ne_zero (S : PeriodicSpherePacking d)

end numReps_Related

section Disjoint_Covering_of_Centers

theorem PeriodicSpherePacking.unique_covers_of_centers (S : PeriodicSpherePacking d) -- (hd : 0 < d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))}  -- (hD_isBounded : IsBounded D)
  (hD_unique_covers : ‚àÄ x, ‚àÉ! g : S.lattice, g +·µ• x ‚àà D) -- (hD_measurable : MeasurableSet D)
  :
  ‚àÄ x : S.centers, ‚àÉ! g : S.lattice, (g +·µ• x : EuclideanSpace ‚Ñù (Fin d)) ‚àà S.centers ‚à© D := by
  intro x
  obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := hD_unique_covers (x : EuclideanSpace ‚Ñù (Fin d))
  use g
  simp only [Set.mem_inter_iff, Subtype.coe_prop, true_and, Subtype.forall] at hg‚ÇÅ hg‚ÇÇ ‚ä¢
  constructor
  ¬∑ exact hg‚ÇÅ
  ¬∑ intro a ha hmem
    exact hg‚ÇÇ a ha hmem

theorem PeriodicSpherePacking.centers_union_over_lattice (S : PeriodicSpherePacking d) -- (hd : 0 < d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))}  -- (hD_isBounded : IsBounded D)
  (hD_unique_covers : ‚àÄ x, ‚àÉ! g : S.lattice, g +·µ• x ‚àà D) -- (hD_measurable : MeasurableSet D)
  : S.centers = ‚ãÉ (g : S.lattice), (g +·µ• S.centers ‚à© D) := by
  ext x
  simp only [Set.mem_iUnion, Subtype.exists, AddSubmonoid.mk_vadd, exists_prop]
  constructor
  ¬∑ intro hx
    obtain ‚ü®g, hg‚ÇÅ, _‚ü© := S.unique_covers_of_centers hD_unique_covers ‚ü®x, hx‚ü©
    use -g
    simp only [neg_mem_iff, SetLike.coe_mem, true_and]
    obtain ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü© := hg‚ÇÅ
    have : ‚àÉ y : D, ‚Üëy = g +·µ• x := by use ‚ü®g +·µ• x, hy‚ÇÇ‚ü©
    obtain ‚ü®y, hy‚ü© := this
    suffices : x = -g +·µ• (y : EuclideanSpace ‚Ñù (Fin d))
    ¬∑ rw [this]
      have hy' := Subtype.coe_prop y
      refine Set.vadd_mem_vadd_set ?h.intro.intro.a
      simp only [Set.mem_inter_iff, hy', and_true]
      rw [hy]
      -- Idea: closure under additive action
      exact hy‚ÇÅ
    rw [hy, neg_vadd_vadd]
  ¬∑ intro hexa
    obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := hexa
    rw [Set.vadd_set_inter, Set.mem_inter_iff] at hg‚ÇÇ
    obtain ‚ü®hg‚ÇÇ, _‚ü© := hg‚ÇÇ
    -- Idea: x = g +·µ• y for some y in the set of centers
    -- Then apply closure under action
    obtain ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü© := hg‚ÇÇ
    simp only [vadd_eq_add] at hy‚ÇÇ
    rw [‚Üê hy‚ÇÇ]
    exact S.lattice_action hg‚ÇÅ hy‚ÇÅ

-- This is true but unnecessary (for now). What's more important is expressing it as a disjoint
-- union over points in X / Œõ = X ‚à© D of translates of the lattice by points in X / Œõ = X ‚à© D or
-- something like that, because that's what's needed for `tsum_finset_bUnion_disjoint`.
theorem PeriodicSpherePacking.translates_disjoint (S : PeriodicSpherePacking d) -- (hd : 0 < d)
  {D : Set (EuclideanSpace ‚Ñù (Fin d))}  -- (hD_isBounded : IsBounded D)
  (hD_unique_covers : ‚àÄ x, ‚àÉ! g : S.lattice, g +·µ• x ‚àà D) -- (hD_measurable : MeasurableSet D)
  : Set.Pairwise ‚ä§ (Disjoint on (fun (g : S.lattice) => g +·µ• S.centers ‚à© D)) -- why the error?
  -- True
  := by
  intro x hx y hy hxy
  obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := hD_unique_covers x
  specialize hg‚ÇÇ y
  simp only  at hg‚ÇÇ
  simp only [Set.disjoint_iff_inter_eq_empty]
  ext z
  simp only [Set.mem_inter_iff, Set.mem_empty_iff_false, iff_false, not_and]
  intro hz‚ÇÅ hz‚ÇÇ
  sorry

-- Can we use some sort of orbit disjointedness result and factor through the equivalence between
-- the `Quotient` and `S.centers ‚à© D`?

end Disjoint_Covering_of_Centers

section Fundamental_Domains_in_terms_of_Basis

open Submodule

variable (S : PeriodicSpherePacking d) (b : Basis (Fin d) ‚Ñ§ S.lattice)

-- I include the following because some lemmas in `PeriodicPacking` have them as assumptions, and
-- I'd like to replace all instances of `D` with `fundamentalDomain (b.ofZlatticeBasis ‚Ñù _)` and
-- the assumptions on `D` with the following lemmas.

-- Note that we have `Zspan.fundamentalDomain_isBounded`. We can use this to prove the following,
-- which is necessary for `PeriodicSpherePacking.density_eq`.
theorem PeriodicSpherePacking.exists_bound_on_fundamental_domain :
  ‚àÉ L : ‚Ñù, ‚àÄ x ‚àà fundamentalDomain (b.ofZlatticeBasis ‚Ñù _), ‚Äñx‚Äñ ‚â§ L :=
  isBounded_iff_forall_norm_le.1 (fundamentalDomain_isBounded (Basis.ofZlatticeBasis ‚Ñù S.lattice b))

-- Note that we have `Zspan.exist_unique_vadd_mem_fundamentalDomain`. We can use this to prove the
-- following.
theorem PeriodicSpherePacking.fundamental_domain_unique_covers :
   ‚àÄ x, ‚àÉ! g : S.lattice, g +·µ• x ‚àà fundamentalDomain (b.ofZlatticeBasis ‚Ñù _) := by
  have : S.lattice = (span ‚Ñ§ (Set.range (b.ofZlatticeBasis ‚Ñù _))).toAddSubgroup :=
    Eq.symm (Basis.ofZlatticeBasis_span ‚Ñù S.lattice b)
  intro x
  -- The `g` we need should be the negative of the floor of `x`, but we can obtain it from the
  -- existing library result.
  obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := exist_unique_vadd_mem_fundamentalDomain (b.ofZlatticeBasis ‚Ñù _) x
  have hg_mem : ‚Üëg ‚àà S.lattice := by simp only [this, mem_toAddSubgroup, SetLike.coe_mem]
  use ‚ü®‚Üëg, hg_mem‚ü©
  constructor
  ¬∑ exact hg‚ÇÅ
  ¬∑ intro y
    have hy_mem : ‚Üëy ‚àà (span ‚Ñ§ (Set.range ‚áë(Basis.ofZlatticeBasis ‚Ñù S.lattice b))).toAddSubgroup :=
      by simp only [‚Üê this, SetLike.coe_mem]
    intro hy
    simp only at hg‚ÇÇ ‚ä¢
    specialize hg‚ÇÇ ‚ü®y, hy_mem‚ü© hy
    refine SetCoe.ext ?h.right.a
    have heq : ‚Üëy = (g : EuclideanSpace ‚Ñù (Fin d)) := by rw [‚Üê hg‚ÇÇ]
    exact heq

-- Note that we already have `Zspan.fundamentalDomain_measurableSet`. Use
-- `fundamentalDomain_measurableSet (Basis.ofZlatticeBasis ‚Ñù S.lattice b)` to say that our desired
-- fundamental domain is measurable.

end Fundamental_Domains_in_terms_of_Basis

section Periodic_Density_Formula

noncomputable instance HDivENNReal : HDiv NNReal ENNReal ENNReal where
  hDiv := fun x y => x / y
noncomputable instance HMulENNReal : HMul NNReal ENNReal ENNReal where
  hMul := fun x y => x * y

noncomputable def PeriodicSpherePacking.basis_index_equiv (P : PeriodicSpherePacking d) :
  (Module.Free.ChooseBasisIndex ‚Ñ§ ‚Ü•P.lattice) ‚âÉ (Fin d) := by
  refine Fintype.equivFinOfCardEq ?h
  rw [‚Üê FiniteDimensional.finrank_eq_card_chooseBasisIndex, Zlattice.rank ‚Ñù P.lattice,
      finrank_euclideanSpace, Fintype.card_fin]

/- Here's a version of `PeriodicSpherePacking.density_eq` that
1. Does not require the `hL` hypothesis that the original one does
2. Uses `Zlattice.covolume` instead of the `volume` of a basis-dependent `fundamentalDomain`
-/
@[simp]
theorem PeriodicSpherePacking.density_eq'
  (S : PeriodicSpherePacking d) (hd : 0 < d) : S.density =
  (ENat.toENNReal (S.numReps : ENat)) *
  volume (ball (0 : EuclideanSpace ‚Ñù (Fin d)) (S.separation / 2)) /
  Real.toNNReal (Zlattice.covolume S.lattice) := by
  let b : Basis (Fin d) ‚Ñ§ ‚Ü•S.lattice := ((Zlattice.module_free ‚Ñù S.lattice).chooseBasis).reindex
    (S.basis_index_equiv)
  obtain ‚ü®L, hL‚ü© := S.exists_bound_on_fundamental_domain b
  rw [Real.toNNReal_of_nonneg (LT.lt.le (Zlattice.covolume_pos S.lattice volume))]
  rw [S.density_eq b hL hd]
  simp only [ENat.toENNReal_coe]
  apply congrArg _ _
  refine (ENNReal.toReal_eq_toReal_iff' ?hx ?hy).mp ?_
  ¬∑ rw [‚Üê lt_top_iff_ne_top]
    letI := fundamentalDomain_isBounded (Basis.ofZlatticeBasis ‚Ñù S.lattice b)
    exact IsBounded.measure_lt_top this
  ¬∑ exact ENNReal.coe_ne_top
  ¬∑ rw [ENNReal.coe_toReal, NNReal.coe_mk]
    refine Eq.symm (Zlattice.covolume_eq_measure_fundamentalDomain S.lattice volume ?h)
    exact Zlattice.isAddFundamentalDomain b volume

theorem periodic_constant_eq_constant (hd : 0 < d) :
    PeriodicSpherePackingConstant d = SpherePackingConstant d := by
  sorry

end Periodic_Density_Formula

section Empty_Centers

theorem PeriodicSpherePacking.density_of_centers_empty (S : PeriodicSpherePacking d) (hd : 0 < d)
  [instEmpty : IsEmpty S.centers] : S.density = 0 := by
  -- Idea: Use formula
  -- (We are using `IsEmpty` in order to do cases on `isEmpty_or_nonempty` in proofs)
  rw [S.density_eq' hd]
  let b := ((Zlattice.module_free ‚Ñù S.lattice).chooseBasis).reindex (S.basis_index_equiv)
  let D := fundamentalDomain (Basis.ofZlatticeBasis ‚Ñù S.lattice b)
  have hD_isBounded : IsBounded D := fundamentalDomain_isBounded (Basis.ofZlatticeBasis ‚Ñù S.lattice b)
  have hD_unique_covers : ‚àÄ x, ‚àÉ! g : S.lattice, g +·µ• x ‚àà D :=
    S.fundamental_domain_unique_covers b
  rw [‚Üê S.card_centers_inter_isFundamentalDomain D hD_isBounded hD_unique_covers hd]
  simp only [Set.toFinset_card, ENat.toENNReal_coe, ENNReal.div_eq_zero_iff, mul_eq_zero,
    Nat.cast_eq_zero, ENNReal.coe_ne_top, or_false]
  left
  letI instFintype := @Fintype.ofFinite _ <| aux4 S D hD_isBounded hd
  rw [Fintype.card_eq_zero_iff]
  refine Set.isEmpty_coe_sort.mpr ?h.a
  suffices : S.centers = ‚àÖ
  ¬∑ rw [this]
    exact Set.empty_inter D
  exact Set.isEmpty_coe_sort.mp instEmpty

theorem SpherePacking.density_of_centers_empty (S : SpherePacking d) (hd : 0 < d)
  [instEmpty : IsEmpty S.centers] : S.density = 0 := by
  -- Idea: construct a periodic sphere packing with some lattice and the same set of centres
  -- Show that its toSpherePacking is the same as S
  -- Then use formula
  let b : Basis (Fin d) ‚Ñù (EuclideanSpace ‚Ñù (Fin d)) := (EuclideanSpace.basisFun (Fin d) ‚Ñù).toBasis
  let Œõ := (Submodule.span ‚Ñ§ (Set.range b)).toAddSubgroup
  let P : PeriodicSpherePacking d := {
    centers := S.centers
    separation := S.separation
    separation_pos := S.separation_pos
    centers_dist := S.centers_dist
    lattice := Œõ
    lattice_action := by
      simp only
      intros x y _ hy
      rw [Set.isEmpty_coe_sort.mp instEmpty, Set.mem_empty_iff_false] at hy
      exfalso
      exact hy
    lattice_discrete := -- `by infer_instance` also works for this and the next one
      instDiscreteTopologySubtypeMemSubmoduleIntSpanRangeCoeBasisRealOfFinite b
    lattice_isZlattice := _root_.Zspan.isZlattice b
  }
  have h‚ÇÅ : P.toSpherePacking = S := rfl
  rw [‚Üê h‚ÇÅ]
  exact P.density_of_centers_empty hd

end Empty_Centers

open scoped FourierTransform

section Fourier

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E]

variable {V : Type*} [NormedAddCommGroup V]
  [InnerProductSpace ‚Ñù V] [MeasurableSpace V] [BorelSpace V] [FiniteDimensional ‚Ñù V]

-- Super surprised not to find this in Mathlib!
-- @[simp]
-- def fourierIntegral (f : V ‚Üí E) : ùìï‚Åª (ùìï f) = f := by
--   ext x
--   refine Integrable.fourier_inversion ?h.hf ?h.h'f ?h.hv
--   sorry

end Fourier

noncomputable section Misc

-- For some reason the following two instances seem to need restating...
instance (v : EuclideanSpace ‚Ñù (Fin d)) : Decidable (v = 0) := Classical.propDecidable (v = 0)

instance : DecidableEq (EuclideanSpace ‚Ñù (Fin d)) :=
  Classical.typeDecidableEq (EuclideanSpace ‚Ñù (Fin d))

-- Now a small theorem from Complex analysis:
local notation "conj" => starRingEnd ‚ÑÇ
theorem Complex.exp_neg_real_I_eq_conj (x m : EuclideanSpace ‚Ñù (Fin d)) :
  cexp (-(2 * ‚ÜëœÄ * I * ‚Üë‚ü™x, m‚ü´_‚Ñù)) = conj (cexp (2 * ‚ÜëœÄ * I * ‚Üë‚ü™x, m‚ü´_‚Ñù)) :=
  calc cexp (-(2 * ‚ÜëœÄ * I * ‚Üë‚ü™x, m‚ü´_‚Ñù))
  _ = Circle.exp (-2 * œÄ * ‚ü™x, m‚ü´_‚Ñù)
      := by
          rw [Circle.coe_exp]
          push_cast
          ring_nf
  _ = conj (Circle.exp (2 * œÄ * ‚ü™x, m‚ü´_‚Ñù))
      := by rw [mul_assoc, neg_mul, ‚Üê mul_assoc, ‚Üê Circle.coe_inv_eq_conj, Circle.exp_neg]
  _= conj (cexp (2 * ‚ÜëœÄ * I * ‚Üë‚ü™x, m‚ü´_‚Ñù))
      := by
          rw [Circle.coe_exp]
          apply congrArg conj
          push_cast
          ring_nf

end Misc
