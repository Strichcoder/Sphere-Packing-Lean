import Mathlib.Analysis.Complex.UpperHalfPlane.Basic
import Mathlib.NumberTheory.ModularForms.Basic
import Mathlib.NumberTheory.ModularForms.CongruenceSubgroups
import Mathlib.NumberTheory.ModularForms.SlashInvariantForms

/-!
# Auxiliary theorems for the slash actions groups SL(2, ℤ) and Γ(2)

Define special generators S, T, -I (resp. α, β, -I) for SL(2,ℤ) (resp. Γ(2)) and prove that
they are indeed generators.
As a corollary, we only need to check the invariance under these special elements to check
the invariance under the whole group.
These theorems will be used to prove that 4-th powers of Jacobi theta functions Θ_2^4, Θ_3^4, Θ_4^4
are modular forms of weight 2 and level Γ(2).
-/

open scoped MatrixGroups ModularForm
open Matrix UpperHalfPlane CongruenceSubgroup ModularGroup

local notation "GL(" n ", " R ")" "⁺" => Matrix.GLPos (Fin n) R
local notation "Γ " n:100 => Gamma n

def α : Γ 2 := ⟨⟨!![1, 2; 0, 1], by simp⟩, by simp; decide⟩
def β : Γ 2 := ⟨⟨!![1, 0; 2, 1], by simp⟩, by simp; decide⟩
def negI : Γ 2 := ⟨⟨!![-1, 0; 0, -1], by simp⟩, by simp⟩

theorem α_eq_T_sq : α = ⟨T ^ 2,  by simp [sq, T]; decide⟩ := by
  ext
  simp [α, T, sq]

theorem even_weight_negI_action (f : ℍ → ℂ) (k : ℤ) (hk : Even k) : (f ∣[k] negI = f) := by
  ext x
  have h_num : num negI x = -x := by simp [negI, num]
  have h_denom : denom negI x = -1 := by simp [negI, denom]
  have h_apply : (negI : GL(2, ℝ)⁺) • x = x := by
    change smulAux negI x = x
    simp [smulAux, smulAux', h_num, h_denom]
  simp [ModularForm.subgroup_slash, SlashAction.map, ModularForm.slash, hk.neg_one_zpow, *]

section slashaction_generators

theorem SL2Z_generate : (⊤ : Subgroup SL(2, ℤ)) = Subgroup.closure {S, T, ↑negI} := by
  ext ⟨x, hx_det⟩
  simp only [Subgroup.mem_top, Set.mem_univ, SetLike.mem_coe, true_iff]
  -- now prove that all 2x2 matrices with det 1 is in closure of S, T, and -I
  sorry

theorem Γ2_generate : (⊤ : Subgroup (Γ 2)) = Subgroup.closure {α, β, negI} := by
  ext ⟨x, hx_det⟩
  simp only [Subgroup.mem_top, Set.mem_univ, SetLike.mem_coe, true_iff]
  -- now prove that all 2x2 matrices with det 1 and equivalent to I modulo 2
  -- is in closure of α, β, and -I
  sorry

/-- If `G` is generated by a set `s`, then the slash action by elements in G is
uniquely determined by the slash action by elements in s. See `slashaction_generators'` for a
version where `s` is a set of elements in `G`. -/
theorem slashaction_generators
    (f : ℍ → ℂ) (G : Subgroup SL(2, ℤ)) (s : Set SL(2, ℤ)) (hG : G = Subgroup.closure s) (k : ℤ) :
    (∀ γ : G, f ∣[k] γ = f) ↔ (∀ γ ∈ s, f ∣[k] γ = f) := by
  subst hG
  constructor <;> intro h
  · intro γ hγ
    convert h ⟨γ, Subgroup.subset_closure hγ⟩
  · intro ⟨γ, hγ⟩
    -- key idea: this lemma allows induction on the "words" of the group
    apply Subgroup.closure_induction (G := SL(2, ℤ)) (p := fun γ ↦ f ∣[k] γ = f) hγ h
    · exact SlashAction.slash_one _ _
    · intro x y hx hy
      rw [SlashAction.slash_mul, hx, hy]
    · intro x hx
      rw [← hx, ← SlashAction.slash_mul, mul_inv_self, SlashAction.slash_one, hx]

/-- If `G` is generated by a set `s`, then the slash action by elements in G is
uniquely determined by the slash action by elements in s. See `slashaction_generators` for a
version where `s` is a set of elements in SL(2, ℤ). -/
theorem slashaction_generators'
    (f : ℍ → ℂ) {G : Subgroup SL(2, ℤ)} (s : Set G) (hG : ⊤ = Subgroup.closure s) (k : ℤ) :
    (∀ γ : G, f ∣[k] γ = f) ↔ (∀ γ ∈ s, f ∣[k] γ = f) := by
  constructor <;> intro h
  · intro γ _
    exact h _
  · intro ⟨γ, hγ⟩
    -- key idea: this lemma allows induction on the "words" of the group
    apply Subgroup.closure_induction (G := G) (p := fun γ ↦ f ∣[k] γ = f) (k := s) ?_ ?_
    · exact SlashAction.slash_one _ _
    · intro x y hx hy
      rw [SlashAction.slash_mul, hx, hy]
    · intro x hx
      rw [← hx, ← SlashAction.slash_mul, mul_inv_self, SlashAction.slash_one, hx]
    · simp [← hG]
    · intro γ hγ
      exact h γ hγ

theorem slashaction_generators_SL2Z
    (f : ℍ → ℂ) (k : ℤ) (hS : f ∣[k] S = f) (hT : f ∣[k] T = f) (hnegI : f ∣[k] negI = f) :
    (∀ γ : SL(2, ℤ), f ∣[k] γ = f) := by
  intro γ
  refine (slashaction_generators f ⊤ _ SL2Z_generate k).mpr ?_ ⟨γ, by simp⟩
  intro γ hγ
  rcases hγ with (rfl | rfl | rfl | _) <;> assumption

theorem slashaction_generators_Γ2
    (f : ℍ → ℂ) (k : ℤ) (hα : f ∣[k] α = f) (hβ : f ∣[k] β = f) (hnegI : f ∣[k] negI = f) :
    (∀ γ : Γ 2, f ∣[k] γ = f) := by
  intro γ
  refine (slashaction_generators' f {α, β, negI} Γ2_generate k).mpr ?_ γ
  intro γ hγ
  rcases hγ with (rfl | rfl | rfl | _) <;> assumption

end slashaction_generators
