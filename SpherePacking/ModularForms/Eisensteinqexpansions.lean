import Mathlib
import SpherePacking.ModularForms.summable_lems

open ModularForm EisensteinSeries UpperHalfPlane TopologicalSpace Set MeasureTheory intervalIntegral
  Metric Filter Function Complex MatrixGroups

open scoped Interval Real NNReal ENNReal Topology BigOperators Nat Classical

open ArithmeticFunction

noncomputable section Definitions

def standardcongruencecondition : Fin 2 ‚Üí ZMod ((1 : ‚Ñï+) : ‚Ñï) := 0

def E (k : ‚Ñ§) (hk : 3 ‚â§ k) : ModularForm (CongruenceSubgroup.Gamma ‚Üë1) k :=
  (1/2 : ‚ÑÇ) ‚Ä¢ eisensteinSeries_MF hk standardcongruencecondition /-they need  1/2 for the
    normalization to match up (since the sum here is taken over coprime integers).-/

abbrev ‚Ñç' := {z : ‚ÑÇ | 0 < z.im}

open Pointwise

def gammaSetN (N : ‚Ñï) : Set (Fin 2 ‚Üí ‚Ñ§) := ({N} : Set ‚Ñï) ‚Ä¢ gammaSet 1 0

def gammaSetN_map (N : ‚Ñï) (v : gammaSetN N) : gammaSet 1 0 := by
  have hv2 := v.2
  simp [gammaSetN] at hv2
  rw [@mem_smul_set] at hv2
  use hv2.choose
  exact hv2.choose_spec.1

lemma gammaSet_top_mem (v : Fin 2 ‚Üí ‚Ñ§)  : v ‚àà gammaSet 1 0 ‚Üî IsCoprime (v 0) (v 1) := by
  rw [gammaSet]
  simp only [Fin.isValue, mem_setOf_eq, and_iff_right_iff_imp]
  intro h
  exact Subsingleton.eq_zero (Int.cast ‚àò v)

lemma gammaSetN_map_eq (N : ‚Ñï) (v : gammaSetN N) : v.1 = N ‚Ä¢ gammaSetN_map N v := by
  have hv2 := v.2
  simp [gammaSetN] at hv2
  rw [@mem_smul_set] at hv2
  have h1 := hv2.choose_spec.2
  exact h1.symm

def gammaSetN_Equiv (N : ‚Ñï) (hN : N ‚â† 0) : gammaSetN N ‚âÉ gammaSet 1 0 where
  toFun v := gammaSetN_map N v
  invFun v := by
    use N ‚Ä¢ v
    simp only [gammaSetN, singleton_smul, nsmul_eq_mul, mem_smul_set]
    use v
    simp
  left_inv v := by
    simp_rw [‚Üê gammaSetN_map_eq N v]
  right_inv v := by
    simp
    have H : N ‚Ä¢ v.1 ‚àà gammaSetN N := by
      simp [gammaSetN]
      rw [@mem_smul_set]
      use v.1
      simp
    rw [gammaSetN]  at H
    simp at H
    rw [@mem_smul_set] at H
    simp at H
    let x := H.choose
    have hx := H.choose_spec
    have hxv : ‚ü®x, hx.1‚ü©   = v := by
      ext i
      have hhxi := congr_fun hx.2 i
      simp [hN] at hhxi
      exact hhxi
    simp_rw [‚Üê hxv]
    rw [gammaSetN_map]
    simp_all only [ne_eq, nsmul_eq_mul, x]

lemma gammaSetN_eisSummand (k : ‚Ñ§) (z : ‚Ñç) (n : ‚Ñï) (v : gammaSetN n) : eisSummand k v z =
  ((n : ‚ÑÇ)^k)‚Åª¬π * eisSummand k (gammaSetN_map n v) z := by
  simp only [eisSummand, gammaSetN_map_eq n v, Fin.isValue, Pi.smul_apply, nsmul_eq_mul,
    Int.cast_mul, Int.cast_natCast, zpow_neg, ‚Üê mul_inv]
  congr
  rw [‚Üê mul_zpow]
  ring_nf

def GammaSet_one_Equiv : (Fin 2 ‚Üí ‚Ñ§) ‚âÉ (Œ£n : ‚Ñï, gammaSetN n) where
  toFun v := ‚ü®(v 0).gcd (v 1), ‚ü®(v 0).gcd (v 1) ‚Ä¢ ![(v 0)/(v 0).gcd (v 1), (v 1)/(v 0).gcd (v 1)], by
  by_cases hn : 0 < (v 0).gcd (v 1)
  apply Set.smul_mem_smul
  simp only [Fin.isValue, mem_singleton_iff]
  rw [gammaSet_top_mem, Int.isCoprime_iff_gcd_eq_one]
  apply Int.gcd_div_gcd_div_gcd hn
  simp only [Fin.isValue, not_lt, nonpos_iff_eq_zero] at hn
  rw [hn]
  simp only [singleton_smul, Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue,
    CharP.cast_eq_zero, EuclideanDomain.div_zero, zero_smul, gammaSetN]
  use ![1,1]
  simp only [gammaSet_top_mem, Fin.isValue, Matrix.cons_val_zero, Matrix.cons_val_one,
    Matrix.head_cons, zero_smul, and_true]
  exact Int.isCoprime_iff_gcd_eq_one.mpr rfl ‚ü©‚ü©
  invFun v := v.2
  left_inv v := by
            ext i
            fin_cases i
            refine Int.mul_ediv_cancel' Int.gcd_dvd_left
            refine Int.mul_ediv_cancel' Int.gcd_dvd_right
  right_inv v := by
           ext i
           have hv2 := v.2.2
           simp only [gammaSetN, singleton_smul, mem_smul_set] at hv2
           obtain ‚ü®x, hx‚ü© := hv2
           simp_rw [‚Üê hx.2]
           simp only [Fin.isValue, Pi.smul_apply, nsmul_eq_mul]
           have hg := hx.1.2
           rw [@Int.isCoprime_iff_gcd_eq_one] at hg
           rw [Int.gcd_mul_left, hg]
           omega
           fin_cases i
           refine Int.mul_ediv_cancel'  Int.gcd_dvd_left
           refine Int.mul_ediv_cancel' Int.gcd_dvd_right

/-this is in a PR-/
theorem cot_series_rep (z : ‚Ñç) :
    ‚ÜëœÄ * cot (‚ÜëœÄ * z) - 1 / z = ‚àë' n : ‚Ñï+, (1 / ((z : ‚ÑÇ) - n) + 1 / (z + n)) := by sorry


lemma EisensteinSeries_Identity (z : ‚Ñç) :
    1 / z + ‚àë' n : ‚Ñï+, (1 / ((z : ‚ÑÇ) - n) + 1 / (z + n)) =
      œÄ * Complex.I - 2 * œÄ * Complex.I * ‚àë' n : ‚Ñï, Complex.exp (2 * œÄ * Complex.I * z) ^ n := by
  have h1 := cot_series_rep z
  rw [pi_mul_cot_pi_q_exp z ] at h1
  rw [‚Üê h1]
  ring



theorem upper_ne_int (x : ‚Ñç) (d : ‚Ñ§) : (x : ‚ÑÇ) + d ‚â† 0 :=
  by
  by_contra h
  rw [add_eq_zero_iff_eq_neg] at h
  have h1 : 0 < (x : ‚ÑÇ).im := by simp [x.2]; exact im_pos x
  rw [h] at h1
  simp at h1

theorem aut_iter_deriv (d : ‚Ñ§) (k : ‚Ñï) :
    EqOn (iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z + d)) {z : ‚ÑÇ | 0 < z.im})
      (fun t : ‚ÑÇ => (-1) ^ k * k ! * (1 / (t + d) ^ (k + 1))) {z : ‚ÑÇ | 0 < z.im} := by
  intro x hx
  induction' k with k IH generalizing x
  simp only [iteratedDerivWithin_zero, pow_zero, Nat.factorial_zero, algebraMap.coe_one, pow_one,
    one_mul]
  simp  at *
  rw [iteratedDerivWithin_succ]
  simp only [one_div, Opens.coe_mk, Nat.cast_succ, Nat.factorial, Nat.cast_mul]
  have := (IH hx)
  have H : derivWithin (fun (z : ‚ÑÇ) => (-1: ‚ÑÇ) ^ k * ‚Üëk ! * ((z + ‚Üëd) ^ (k + 1))‚Åª¬π) {z : ‚ÑÇ | 0 < z.im} x =
   (-1) ^ (‚Üëk + 1) * ((‚Üëk + 1) * ‚Üëk !) * ((x + ‚Üëd) ^ (‚Üëk + 1 + 1))‚Åª¬π := by
    rw [DifferentiableAt.derivWithin]
    ¬∑ simp only [deriv_const_mul_field']
      rw [deriv_inv'', deriv_pow'', deriv_add_const', deriv_id'']
      simp only [Nat.cast_add, Nat.cast_one, add_tsub_cancel_right, mul_one, ‚Üê pow_mul]
      rw [pow_add]
      simp only [Int.cast_mul, Int.cast_pow, Int.cast_negSucc, zero_add, Nat.cast_one,
        Int.cast_ofNat, Nat.cast_add,pow_one, Nat.cast_mul, mul_neg, mul_one, Int.cast_add,
          Int.cast_one, neg_mul]
      have Hw : -(((k: ‚ÑÇ) + 1) * (x + ‚Üëd) ^ k) / (x + ‚Üëd) ^ ((k + 1) * 2) = -(‚Üëk + 1) / (x + ‚Üëd) ^ (k + 2) :=
        by
        rw [div_eq_div_iff]
        norm_cast
        simp
        ring
        norm_cast
        apply pow_ne_zero ((k + 1) * 2) (upper_ne_int ‚ü®x, hx‚ü© d)
        norm_cast
        apply pow_ne_zero (k + 2) (upper_ne_int ‚ü®x, hx‚ü© d)

      simp at *
      rw [Hw]
      ring
      fun_prop
      fun_prop
      norm_cast
      apply pow_ne_zero (k + 1) (upper_ne_int ‚ü®x, hx‚ü© d)
    ¬∑ apply DifferentiableAt.mul
      ¬∑ fun_prop
      ¬∑ apply DifferentiableAt.inv
        fun_prop
        apply pow_ne_zero (k + 1) (upper_ne_int ‚ü®x, hx‚ü© d)
    ¬∑ apply IsOpen.uniqueDiffWithinAt _ hx
      refine isOpen_lt ?_ ?_
      ¬∑ fun_prop
      ¬∑ fun_prop
  rw [‚ÜêH]
  apply derivWithin_congr
  norm_cast at *
  simp at *
  intro r hr
  apply IH hr
  norm_cast at *
  simp at *
  apply this

theorem aut_iter_deriv' (d : ‚Ñ§) (k : ‚Ñï) :
    EqOn (iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z - d)) {z : ‚ÑÇ | 0 < z.im})
      (fun t : ‚ÑÇ => (-1) ^ k * k ! * (1 / (t - d) ^ (k + 1))) {z : ‚ÑÇ | 0 < z.im} :=
  by
  intro x hx
  have h1 : (fun z : ‚ÑÇ => 1 / (z - d)) = fun z : ‚ÑÇ => 1 / (z + -d) := by rfl
  rw [h1]
  have h2 : x - d = x + -d := by rfl
  simp_rw [h2]
  simpa using aut_iter_deriv (-d : ‚Ñ§) k hx
/-

theorem hasDerivAt_tsum_fun {Œ± : Type*} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :‚àÄ (K) (_ : K ‚äÜ s), IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), ‚Äñ(deriv (f n) k)‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, deriv (fun z => f n z) x) x :=
  by
  have A :
    ‚àÄ x : ‚ÑÇ,
      x ‚àà s ‚Üí
        Tendsto (fun t : Finset Œ± => ‚àë n in t, (fun z => f n z) x) atTop
          (ùìù (‚àë' n : Œ±, (fun z => f n z) x)) :=
    by
    intro y hy
    apply Summable.hasSum
    simp
    apply hf y hy
  apply hasDerivAt_of_tendstoLocallyUniformlyOn hs _ _ A hx
  use fun n : Finset Œ± => fun a => ‚àë i in n, deriv (fun z => f i z) a
  rw [tendstoLocallyUniformlyOn_iff_forall_isCompact hs]
  intro K hK1 hK2
  have HU := hu K hK1 hK2
  obtain ‚ü®u, hu1, hu2‚ü© := HU
  apply tendstoUniformlyOn_tsum hu1
  intro n x hx
  apply hu2 n ‚ü®x, hx‚ü©
  filter_upwards
  intro t r hr
  apply HasDerivAt.sum
  intro q _
  rw [hasDerivAt_deriv_iff]
  apply hf2 q ‚ü®r, hr‚ü©

theorem hasDerivWithinAt_tsum_fun {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ (K) (_ : K ‚äÜ s),
        IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), ‚Äñ (deriv (f n) k)‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivWithinAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, deriv (fun z => f n z) x) s x := by
  apply (hasDerivAt_tsum_fun f hs x hx hf hu hf2).hasDerivWithinAt

theorem hasDerivWithinAt_tsum_fun' {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ (K) (_ : K ‚äÜ s),
        IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), ‚Äñ (deriv (f n) k)‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivWithinAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, derivWithin (fun z => f n z) s x) s x :=
  by
  have := hasDerivWithinAt_tsum_fun f hs x hx hf hu hf2
  have Hd : (‚àë' (n : Œ±), deriv (fun z => f n z) x) = (‚àë' n : Œ±, derivWithin (fun z => f n z) s x) :=
    by
    apply tsum_congr
    intro n
    apply symm
    apply DifferentiableAt.derivWithin
    apply hf2 n ‚ü®x, hx‚ü©
    apply IsOpen.uniqueDiffWithinAt hs hx
  rw [Hd] at this
  convert this

theorem deriv_tsum_fun' {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) {s : Set ‚ÑÇ}
    (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s) (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ (K) (_ : K ‚äÜ s),
        IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), ‚Äñ (deriv (f n) k)‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    derivWithin (fun z => ‚àë' n : Œ±, f n z) s x = ‚àë' n : Œ±, derivWithin (fun z => f n z) s x := by
  apply
    HasDerivWithinAt.derivWithin (hasDerivWithinAt_tsum_fun' f hs x hx hf hu hf2)
      (IsOpen.uniqueDiffWithinAt hs hx) -/

theorem derivWithin_tsum_fun' {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) {s : Set ‚ÑÇ}
    (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s) (hf : ‚àÄ y ‚àà s, Summable fun n : Œ± => f n y)
    (hu :‚àÄ K ‚äÜ s, IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ n (k : K), ‚ÄñderivWithin (f n) s k‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ n (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    derivWithin (fun z => ‚àë' n : Œ±, f n z) s x = ‚àë' n : Œ±, derivWithin (fun z => f n z) s x := by
  apply HasDerivWithinAt.derivWithin
  apply HasDerivAt.hasDerivWithinAt
  have A :
    ‚àÄ x : ‚ÑÇ,
      x ‚àà s ‚Üí
        Tendsto (fun t : Finset Œ± => ‚àë n in t, (fun z => f n z) x) atTop
          (ùìù (‚àë' n : Œ±, (fun z => f n z) x)) :=
    by
    intro y hy
    apply Summable.hasSum
    simp
    apply hf y hy
  apply hasDerivAt_of_tendstoLocallyUniformlyOn hs _ _ A hx
  use fun n : Finset Œ± => fun a => ‚àë i ‚àà n, derivWithin (fun z => f i z) s a
  rw [tendstoLocallyUniformlyOn_iff_forall_isCompact hs]
  intro K hK1 hK2
  have HU := hu K hK1 hK2
  obtain ‚ü®u, hu1, hu2‚ü© := HU
  apply tendstoUniformlyOn_tsum hu1
  intro n x hx
  apply hu2 n ‚ü®x, hx‚ü©
  filter_upwards
  intro t r hr
  apply HasDerivAt.sum
  intro q hq
  apply HasDerivWithinAt.hasDerivAt
  apply DifferentiableWithinAt.hasDerivWithinAt
  apply (hf2 q ‚ü®r, hr‚ü©).differentiableWithinAt
  exact IsOpen.mem_nhds hs hr
  apply IsOpen.uniqueDiffWithinAt hs hx

theorem aut_contDiffOn (d : ‚Ñ§) (k : ‚Ñï) : ContDiffOn ‚ÑÇ k (fun z : ‚ÑÇ => 1 / (z - d))
    {z : ‚ÑÇ | 0 < z.im} := by
  simp only [one_div, Opens.coe_mk]
  apply ContDiffOn.inv
  apply ContDiffOn.sub
  apply contDiffOn_id
  apply contDiffOn_const
  intro x hx
  have := upper_ne_int ‚ü®x, hx‚ü© (-d)
  norm_cast at *
  simp at *
  rw [add_neg_eq_zero] at this
  rw [sub_eq_zero]
  convert this

theorem iter_div_aut_add (d : ‚Ñ§) (k : ‚Ñï) :
    EqOn (iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z - d) + 1 / (z + d)) {z : ‚ÑÇ | 0 < z.im})
      ((fun t : ‚ÑÇ => (-1) ^ k * k ! * (1 / (t - d) ^ (k + 1))) + fun t : ‚ÑÇ =>
        (-1) ^ k * k ! * (1 / (t + d) ^ (k + 1))) {z : ‚ÑÇ | 0 < z.im} := by
  intro x hx
  have h1 :
    (fun z : ‚ÑÇ => 1 / (z - d) + 1 / (z + d)) =
      (fun z : ‚ÑÇ => 1 / (z - d)) + fun z : ‚ÑÇ => 1 / (z + d) :=
    by rfl
  rw [h1]
  simp only [Opens.coe_mk, one_div, Pi.add_apply] at *
  rw [iteratedDerivWithin_add hx ?_]
  ¬∑ have h2 := aut_iter_deriv d k hx
    have h3 := aut_iter_deriv' d k hx
    simp at *
    rw [h2, h3]
  ¬∑ have h4 := aut_contDiffOn d k
    simp at h4
    apply h4
    exact hx
  ¬∑ have h5 := aut_contDiffOn (-d) k
    simp at h5
    apply h5
    exact hx
  ¬∑ refine IsOpen.uniqueDiffOn ?_
    refine isOpen_lt ?_ ?_
    ¬∑ fun_prop
    ¬∑ fun_prop

theorem summable_1 (k : ‚Ñï) (z : ‚Ñç) (hk : 1 ‚â§ k) :
    Summable fun (b : ‚Ñï) ‚Ü¶ (((z : ‚ÑÇ) - ‚Üë‚Üëb) ^ (k + 1))‚Åª¬π := by
  have := summable_hammerTime_nat (fun n : ‚Ñï => (((z : ‚ÑÇ) - n) ^ (k + 1))) (k+1)
      (by norm_cast; omega) ?_
  apply this
  norm_cast
  simp_rw [‚Üê inv_pow]
  have : (fun (n : ‚Ñï) ‚Ü¶ (‚Üë(n ^ (k + 1)) : ‚Ñù)‚Åª¬π) = fun (n : ‚Ñï) ‚Ü¶ (‚Üë(n : ‚Ñù)‚Åª¬π)  ^ (k + 1) := by
    simp
  conv =>
    enter [3]
    rw [this]
  apply Asymptotics.IsBigO.pow
  have hl := linear_bigO_nat (-1) z
  conv =>
    enter [2]
    intro x
    rw [sub_eq_add_neg]
  apply Asymptotics.IsBigO.of_abs_right
  simp only [Nat.cast_pow, inv_pow, Int.reduceNeg, Int.cast_neg, Int.cast_one, neg_mul, one_mul,
    Nat.abs_cast, Asymptotics.isBigO_abs_right] at *
  have hl2 := Asymptotics.IsBigO.neg_left hl
  apply hl2.congr_left
  intro n
  rw [@neg_inv]
  congr
  ring

theorem summable_2 (k : ‚Ñï) (z : ‚Ñç) (hk : 1 ‚â§ k) :
    Summable fun (b : ‚Ñï) ‚Ü¶ (((z : ‚ÑÇ) + ‚Üë‚Üëb) ^ (k + 1))‚Åª¬π := by
  have := summable_hammerTime_nat (fun n : ‚Ñï => (((z : ‚ÑÇ) + n) ^ (k + 1))) (k+1)
      (by norm_cast; omega) ?_
  apply this
  norm_cast
  simp_rw [‚Üê inv_pow]
  have : (fun (n : ‚Ñï) ‚Ü¶ (‚Üë(n ^ (k + 1)) : ‚Ñù)‚Åª¬π) = fun (n : ‚Ñï) ‚Ü¶ (‚Üë(n : ‚Ñù)‚Åª¬π)  ^ (k + 1) := by simp
  conv =>
    enter [3]
    rw [this]
  apply Asymptotics.IsBigO.pow
  have hl := linear_bigO_nat 1 z
  apply Asymptotics.IsBigO.of_abs_right
  simp only [Nat.cast_pow, inv_pow, Int.cast_one, one_mul, Nat.abs_cast,
    Asymptotics.isBigO_abs_right] at *
  exact hl

theorem summable_iter_aut (k : ‚Ñï) (z : ‚Ñç) :
    Summable fun n : ‚Ñï+ => iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z - n) + 1 / (z + n))
      {z : ‚ÑÇ | 0 < z.im} z :=
  by
  have := fun d : ‚Ñï+ => iter_div_aut_add d k z.2
  simp only [Int.cast_natCast, one_div, Pi.add_apply] at *
  have ht := (summable_congr this).2 ?_
  norm_cast at *
  by_cases hk : 1 ‚â§ k
  conv =>
    enter [1]
    ext b
    rw [‚Üê mul_add]
  rw [summable_mul_left_iff]
  apply Summable.add
  ¬∑ apply (summable_1 k z hk).subtype
  ¬∑ apply (summable_2 k z hk).subtype
  simp only [ne_eq, mul_eq_zero, pow_eq_zero_iff', neg_eq_zero, one_ne_zero, false_and,
    Nat.cast_eq_zero, false_or]
  exact Nat.factorial_ne_zero k
  simp only [not_le, Nat.lt_one_iff] at hk
  simp_rw [hk]
  simp only [pow_zero, Nat.factorial_zero, Nat.cast_one, mul_one, zero_add, pow_one, one_mul]
  simpa using lhs_summable z


example (a : ‚ÑÇ) (n : ‚Ñï) : (a ^ n)‚Åª¬π = a ^ (-n : ‚Ñ§) := by
  simp only [zpow_neg, zpow_natCast]

lemma sub_bound (s : {z : ‚ÑÇ | 0 < z.im}) (A B : ‚Ñù) (hB : 0 < B) (hs : s ‚àà verticalStrip A B) (k : ‚Ñï)
    (n : ‚Ñï+) :
    ‚Äñ((-1 : ‚ÑÇ) ^ (k + 1) * (k + 1)! * (1 / (s - n) ^ (k + 2)))‚Äñ ‚â§
    ‚Äñ((k + 1)! / r ‚ü®‚ü®A, B‚ü©, by simp [hB]‚ü© ^ (k + 2)) * ((n : ‚Ñù) ^ ((k : ‚Ñ§) +2))‚Åª¬π‚Äñ := by
  simp
  rw [div_eq_mul_inv]
  rw [mul_assoc]
  gcongr
  have := summand_bound_of_mem_verticalStrip (k := (k + 2)) (by norm_cast; omega) ![1,-n] hB hs
  simp at *
  simp_rw [‚Üê zpow_natCast, ‚Üê zpow_neg]
  convert this
  rw [Int.natCast_add]
  simp [sub_eq_add_neg]
  norm_cast
  simp
  norm_cast
  congr
  rw [@abs_eq_self]
  apply (EisensteinSeries.r_pos _).le
  rw [EisensteinSeries.norm_eq_max_natAbs]
  simp
  norm_cast
  congr
  simp
  exact n.2


lemma add_bound (s : {z : ‚ÑÇ | 0 < z.im}) (A B : ‚Ñù) (hB : 0 < B) (hs : s ‚àà verticalStrip A B) (k : ‚Ñï)
    (n : ‚Ñï+) :
    ‚Äñ((-1 : ‚ÑÇ) ^ (k + 1) * (k + 1)! * (1 / (s + n) ^ (k + 2)))‚Äñ ‚â§
    ‚Äñ((k + 1)! / r ‚ü®‚ü®A, B‚ü©, by simp [hB]‚ü© ^ (k + 2)) * ((n : ‚Ñù) ^ ((k : ‚Ñ§) +2))‚Åª¬π‚Äñ := by
  simp
  rw [div_eq_mul_inv]
  rw [mul_assoc]
  gcongr
  have := summand_bound_of_mem_verticalStrip (k := (k + 2)) (by norm_cast; omega) ![1,n] hB hs
  simp at *
  simp_rw [‚Üê zpow_natCast, ‚Üê zpow_neg]
  convert this
  rw [Int.natCast_add]
  simp
  norm_cast
  rw [Int.natCast_add]
  simp
  norm_cast
  congr
  rw [@abs_eq_self]
  apply (EisensteinSeries.r_pos _).le
  rw [EisensteinSeries.norm_eq_max_natAbs]
  simp
  norm_cast
  congr
  simp
  exact n.2


theorem aut_bound_on_comp (K : Set {z : ‚ÑÇ | 0 < z.im}) (hk2 : IsCompact K) (k : ‚Ñï) :
    ‚àÉ u : ‚Ñï+ ‚Üí ‚Ñù,
      Summable u ‚àß
        ‚àÄ (n : ‚Ñï+) (s : K),
        ‚Äñ(derivWithin (fun z : ‚ÑÇ =>
        iteratedDerivWithin k (fun z : ‚ÑÇ => (z - (n : ‚ÑÇ))‚Åª¬π + (z + n)‚Åª¬π) {z : ‚ÑÇ | 0 < z.im} z)
        {z : ‚ÑÇ | 0 < z.im} s)‚Äñ ‚â§
            u n := by
  by_cases h1 : Set.Nonempty K
  have H := UpperHalfPlane.subset_verticalStrip_of_isCompact hk2
  obtain ‚ü®A, B, hB, hAB‚ü© := H
  let zAB : ‚Ñç := ‚ü®‚ü®A, B‚ü©, by simp [hB]‚ü©
  refine ‚ü®fun a : ‚Ñï+ => 2 * ‚Äñ((k + 1)! / r (zAB) ^ (k + 2)) * ((a : ‚Ñù) ^ ((k : ‚Ñ§) +2))‚Åª¬π‚Äñ,
      ?_, ?_‚ü©
  conv =>
    enter [1]
    ext a
    rw [norm_mul]
    rw [‚Üê mul_assoc]
  apply Summable.mul_left
  simp
  have : Summable fun (i : ‚Ñï) ‚Ü¶ ((i : ‚Ñù) ^ ((k : ‚Ñ§) + 2))‚Åª¬π := by
    have := (Real.summable_nat_rpow_inv (p := k + 2)).mpr (by linarith)
    apply this.congr
    intro n
    norm_cast
  apply this.subtype
  intro n s
  rw [‚Üê iteratedDerivWithin_succ]
  let S : ‚ÑÇ := s
  have hS : S ‚àà {z : ‚ÑÇ | 0 < z.im} := by
    aesop
  have HT := iter_div_aut_add n (k+1) hS
  simp only [Int.cast_natCast, one_div, Pi.add_apply] at HT
  rw [HT]
  apply le_trans (norm_add_le _ _)
  simp_rw [mul_assoc]
  rw [two_mul]
  apply add_le_add
  have := sub_bound ‚ü®S, hS‚ü© A B hB (by aesop) k n
  simpa using this
  have := add_bound ‚ü®S, hS‚ü© A B hB (by aesop) k n
  simpa using this
  refine' ‚ü®fun _ => 0, _, _‚ü©
  apply summable_zero
  intro n
  rw [not_nonempty_iff_eq_empty] at h1
  intro r
  exfalso
  have hr := r.2
  simp_rw [h1] at hr
  simp at hr

theorem diff_on_aux (k : ‚Ñï) (n : ‚Ñï+) :
    DifferentiableOn ‚ÑÇ
      ((fun t : ‚ÑÇ => (-1 : ‚ÑÇ) ^ k * k ! * (1 / (t - n) ^ (k + 1))) + fun t : ‚ÑÇ =>
        (-1) ^ k * k ! * (1 / (t + n) ^ (k + 1))) {z : ‚ÑÇ | 0 < z.im} := by
  apply DifferentiableOn.add
  apply DifferentiableOn.const_mul
  apply DifferentiableOn.div
  apply differentiableOn_const
  norm_cast
  apply DifferentiableOn.pow
  fun_prop
  intro x hx
  norm_cast
  apply pow_ne_zero
  have := upper_ne_int ‚ü®x, hx‚ü© (-n : ‚Ñ§)
  simp at *
  exact this
  apply DifferentiableOn.const_mul
  apply DifferentiableOn.div
  apply differentiableOn_const
  norm_cast
  apply DifferentiableOn.pow
  fun_prop
  intro x hx
  have := upper_ne_int ‚ü®x, hx‚ü© (n : ‚Ñ§)
  simp at *
  exact this


theorem diff_at_aux (s : {z : ‚ÑÇ | 0 < z.im} ) (k : ‚Ñï) (n : ‚Ñï+) :
    DifferentiableAt ‚ÑÇ
      (fun z : ‚ÑÇ => iteratedDerivWithin k (fun z : ‚ÑÇ => (z - ‚Üën)‚Åª¬π + (z + ‚Üën)‚Åª¬π) {z : ‚ÑÇ | 0 < z.im} z)
      ‚Üës := by
  have := iter_div_aut_add n k
  apply DifferentiableOn.differentiableAt
  apply DifferentiableOn.congr (diff_on_aux k n)
  intro r hr
  have ht := this hr
  simp at *
  apply ht
  apply IsOpen.mem_nhds
  refine isOpen_lt ?_ ?_
  ¬∑ fun_prop
  ¬∑ fun_prop
  ¬∑ simp

theorem aut_series_ite_deriv_uexp2 (k : ‚Ñï) (x : ‚Ñç) :
    iteratedDerivWithin k (fun z : ‚ÑÇ => ‚àë' n : ‚Ñï+, (1 / (z - n) + 1 / (z + n))) {z : ‚ÑÇ | 0 < z.im} x =
      ‚àë' n : ‚Ñï+, iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z - n) + 1 / (z + n)) {z : ‚ÑÇ | 0 < z.im} x :=
  by
  induction' k with k IH generalizing x
  simp only [iteratedDerivWithin_zero]
  rw [iteratedDerivWithin_succ]
  have HH :
    derivWithin (iteratedDerivWithin k (fun z : ‚ÑÇ => ‚àë' n : ‚Ñï+, (1 / (z - n) + 1 / (z + n))) {z : ‚ÑÇ | 0 < z.im} ) {z : ‚ÑÇ | 0 < z.im}
        x =
      derivWithin
        (fun z => ‚àë' n : ‚Ñï+, iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z - n) + 1 / (z + n)) {z : ‚ÑÇ | 0 < z.im}  z) {z : ‚ÑÇ | 0 < z.im}
        x :=
    by
    apply derivWithin_congr
    intro y hy
    apply IH ‚ü®y, hy‚ü©
    apply IH x
  simp_rw [HH]
  simp
  rw [derivWithin_tsum_fun']
  apply tsum_congr
  intro b
  rw [iteratedDerivWithin_succ]
  refine isOpen_lt ?_ ?_
  ¬∑ fun_prop
  ¬∑ fun_prop
  ¬∑ simpa using x.2
  intro y hy
  simpa using summable_iter_aut k ‚ü®y, hy‚ü©
  intro K hK hK2
  let K2 := Set.image (Set.inclusion hK) univ
  have hKK2 : IsCompact (Set.image (inclusion hK) univ) := by
    apply IsCompact.image_of_continuousOn
    ¬∑ exact isCompact_iff_isCompact_univ.mp hK2
    ¬∑ exact continuous_inclusion hK |>.continuousOn
  have := aut_bound_on_comp K2 hKK2 k
  obtain ‚ü®u, hu1, hu2‚ü© := this
  refine ‚ü®u, hu1, ?_‚ü©
  intro n s
  have := hu2 n ‚ü®‚ü®s, by aesop‚ü©, by aesop‚ü©
  apply this
  intro n r
  apply diff_at_aux

theorem tsum_ider_der_eq (k : ‚Ñï) (x : {z : ‚ÑÇ | 0 < z.im}) :
    ‚àë' n : ‚Ñï+, iteratedDerivWithin k (fun z : ‚ÑÇ => 1 / (z - n) + 1 / (z + n)) {z : ‚ÑÇ | 0 < z.im} x =
      ‚àë' n : ‚Ñï+,
        ((-1 : ‚ÑÇ) ^ k * k ! * (1 / (x - n) ^ (k + 1)) + (-1) ^ k * k ! * (1 / (x + n) ^ (k + 1))) :=
  by
  apply tsum_congr
  intro b
  have h2 := iter_div_aut_add b k x.2
  simpa using h2


theorem auxp_series_ite_deriv_uexp''' (k : ‚Ñï) :
    EqOn (iteratedDerivWithin k (fun z : ‚ÑÇ => ‚àë' n : ‚Ñï+, (1 / (z - n) + 1 / (z + n))) {z : ‚ÑÇ | 0 < z.im})
      (fun x : ‚ÑÇ =>
        ‚àë' n : ‚Ñï+,
          ((-1 : ‚ÑÇ) ^ k * k ! * (1 / (x - n) ^ (k + 1)) + (-1) ^ k * k ! * (1 / (x + n) ^ (k + 1))))
      {z : ‚ÑÇ | 0 < z.im} := by
  intro x hx
  have := aut_series_ite_deriv_uexp2 k ‚ü®x, hx‚ü©
  simp at *
  rw [this]
  have h2 := tsum_ider_der_eq k ‚ü®x, hx‚ü©
  simpa using h2

theorem hasDerivAt_tsum_fun {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :‚àÄ K ‚äÜ s, IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), ‚Äñ(derivWithin (f n) s k)‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, derivWithin (fun z => f n z) s x) x :=
  by
  have A :
    ‚àÄ x : ‚ÑÇ,
      x ‚àà s ‚Üí
        Tendsto (fun t : Finset Œ± => ‚àë n ‚àà t, (fun z => f n z) x) atTop
          (ùìù (‚àë' n : Œ±, (fun z => f n z) x)) :=
    by
    intro y hy
    apply Summable.hasSum
    simp
    apply hf y hy
  apply hasDerivAt_of_tendstoLocallyUniformlyOn hs _ _ A hx
  use fun n : Finset Œ± => fun a => ‚àë i ‚àà n, derivWithin (fun z => f i z) s a
  rw [tendstoLocallyUniformlyOn_iff_forall_isCompact hs]
  intro K hK1 hK2
  have HU := hu K hK1 hK2
  obtain ‚ü®u, hu1, hu2‚ü© := HU
  apply tendstoUniformlyOn_tsum hu1
  intro n x hx
  apply hu2 n ‚ü®x, hx‚ü©
  filter_upwards
  intro t r hr
  apply HasDerivAt.sum
  intro q hq
  apply HasDerivWithinAt.hasDerivAt
  apply DifferentiableWithinAt.hasDerivWithinAt
  apply (hf2 q ‚ü®r, hr‚ü©).differentiableWithinAt
  exact IsOpen.mem_nhds hs hr


/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/
theorem hasDerivWithinAt_tsum_fun {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ K ‚äÜ s, IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), ‚Äñ(derivWithin (f n) s k)‚Äñ ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivWithinAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, derivWithin (fun z => f n z) s x) s x := by
  apply (hasDerivAt_tsum_fun f hs x hx hf hu hf2).hasDerivWithinAt


theorem summable_3 (m : ‚Ñï) (y : {z : ‚ÑÇ | 0 < z.im}) :
    Summable fun n : ‚Ñï+ =>
      (-1 : ‚ÑÇ) ^ m * ‚Üëm ! * (1 / (y - ‚Üën) ^ (m + 1)) + (-1) ^ m * ‚Üëm ! * (1 / (y + ‚Üën) ^ (m + 1)) :=
  by
  by_cases hm : m = 0
  simp_rw [hm]
  simp
  have := lhs_summable y
  simpa using this
  have hm2 : 2 ‚â§ m + 1 := by
    have : 1 ‚â§ m := by
      apply Nat.one_le_iff_ne_zero.mpr hm;
    linarith
  simp_rw [‚Üê mul_add]
  rw [summable_mul_left_iff]
  apply Summable.add
  have h0 := summable_1 m y (by linarith)
  simp at *
  apply h0.subtype
  have h1 := summable_2 m y (by linarith)
  simp at *
  apply h1.subtype
  simp [Nat.factorial_ne_zero]

theorem tsum_aexp_contDiffOn (k : ‚Ñï) :
    ContDiffOn ‚ÑÇ k (fun z : ‚ÑÇ => ‚àë' n : ‚Ñï+, (1 / (z - n) + 1 / (z + n))) {z : ‚ÑÇ | 0 < z.im} := by
  apply contDiffOn_of_differentiableOn_deriv
  intro m hm
  have h1 := auxp_series_ite_deriv_uexp''' m
  apply DifferentiableOn.congr _ h1
  intro x hx

  apply HasDerivWithinAt.differentiableWithinAt

  apply hasDerivWithinAt_tsum_fun _ (by refine isOpen_lt (by fun_prop) (by fun_prop))
  apply hx
  intro y hy
  apply summable_3 m ‚ü®y, hy‚ü©
  intro K hK1 hK2
  let K2 := Set.image (Set.inclusion hK1) univ
  have hKK2 : IsCompact (Set.image (inclusion hK1) univ) := by
    apply IsCompact.image_of_continuousOn
    ¬∑ exact isCompact_iff_isCompact_univ.mp hK2
    ¬∑ exact continuous_inclusion hK1 |>.continuousOn
  have := aut_bound_on_comp K2 hKK2 m
  obtain ‚ü®u, hu1, hu2‚ü© := this
  refine ‚ü®u, hu1, ?_‚ü©
  intro n s
  have := hu2 n ‚ü®‚ü®s, by aesop‚ü©, by aesop‚ü©

  apply le_trans _ this
  apply le_of_eq
  congr 1
  apply derivWithin_congr
  have h21 := (iter_div_aut_add n m).symm
  simp at *
  intro v hv
  have h22 := h21 hv
  simp at *
  rw [‚Üê h22]
  have hss : s.1 ‚àà {z : ‚ÑÇ | 0 < z.im} := by
    aesop
  have h21 := (iter_div_aut_add n m).symm hss
  simpa using h21
  intro n r
  have:= (diff_on_aux m n)
  have hN : {z : ‚ÑÇ | 0 < z.im} ‚àà ùìù r.1 := by
    refine IsOpen.mem_nhds ?_ ?_
    apply isOpen_lt (by fun_prop) (by fun_prop)
    apply r.2
  apply DifferentiableOn.differentiableAt _ hN
  simp at *
  apply this



theorem aux_iter_der_tsum (k : ‚Ñï) (hk : 1 ‚â§ k) (x : ‚Ñç) :
    iteratedDerivWithin k
        ((fun z : ‚ÑÇ => 1 / z) + fun z : ‚ÑÇ => ‚àë' n : ‚Ñï+, (1 / (z - n) + 1 / (z + n))) {z : ‚ÑÇ | 0 < z.im} x =
      (-1) ^ (k : ‚Ñï) * (k : ‚Ñï)! * ‚àë' n : ‚Ñ§, 1 / ((x : ‚ÑÇ) + n) ^ (k + 1 : ‚Ñï) := by
  rw [iteratedDerivWithin_add ?_ ?_]
  ¬∑ have h1 := aut_iter_deriv 0 k x.2
    simp [UpperHalfPlane.coe] at *
    rw [h1]

    have := aut_series_ite_deriv_uexp2 k x
    simp [UpperHalfPlane.coe] at *
    rw [this]
    have h2 := tsum_ider_der_eq k x
    simp at h2
    rw [h2]
    rw [int_tsum_pNat]
    ¬∑ simp
      rw [tsum_add]
      ¬∑ rw [tsum_mul_left]
        rw [tsum_mul_left]
        rw [mul_add]
        rw [mul_add]
        conv =>
          enter [2]
          rw [add_assoc]
          conv =>
            enter [2]
            rw [add_comm]
        ring_nf
      rw [summable_mul_left_iff]
      ¬∑ apply (summable_1 k x hk).subtype
      ¬∑ simp
        exact Nat.factorial_ne_zero k
      ¬∑ rw [summable_mul_left_iff]
        ¬∑ apply (summable_2 k x hk).subtype
        ¬∑ simp
          exact Nat.factorial_ne_zero k
    ¬∑ rw [summable_int_iff_summable_nat_and_neg ]
      refine ‚ü®?_, ?_‚ü©
      apply (summable_2 k x hk)
      apply (summable_1 k x hk).congr
      intro n
      congr
      simp
      rfl
  ¬∑ have := (aut_contDiffOn 0 k)
    simp at *
    apply this.contDiffWithinAt
    exact x.2
  ¬∑ apply tsum_aexp_contDiffOn k
    exact x.2
  ¬∑ exact x.2
  ¬∑ refine IsOpen.uniqueDiffOn ?_
    refine isOpen_lt ?_ ?_
    ¬∑ fun_prop
    ¬∑ fun_prop

theorem aux_iter_der_tsum_eqOn (k : ‚Ñï) (hk : 2 ‚â§ k) :
    EqOn
      (iteratedDerivWithin (k - 1)
        ((fun z : ‚ÑÇ => 1 / z) + fun z : ‚ÑÇ => ‚àë' n : ‚Ñï+, (1 / (z - n) + 1 / (z + n))) {z : ‚ÑÇ | 0 < z.im})
      (fun z : ‚ÑÇ => (-1) ^ (k - 1) * (k - 1)! * ‚àë' n : ‚Ñ§, 1 / (z + n) ^ (k : ‚Ñï)) {z : ‚ÑÇ | 0 < z.im} :=
  by
  intro z hz
  have hk0 : 1 ‚â§ k - 1 := le_tsub_of_add_le_left hk
  have := aux_iter_der_tsum (k - 1) hk0 ‚ü®z, hz‚ü©
  have hk1 : k - 1 + 1 = k := by
    apply Nat.sub_add_cancel
    linarith
  rw [hk1] at this
  norm_cast at *


def cts_exp_two_pi_n (K : Set ‚ÑÇ) : ContinuousMap K ‚ÑÇ where
  toFun := fun r : K => Complex.exp (2 * ‚ÜëœÄ * Complex.I * r)

variable {ùïú : Type*} [NontriviallyNormedField ùïú] {F : Type*}
  [NormedAddCommGroup F] [NormedSpace ùïú F] (n : ‚Ñï) (f : ùïú ‚Üí F) (s : Set ùïú) (x : ùïú)


theorem iteratedDerivWithin_of_isOpen (hs : IsOpen s) :
    EqOn (iteratedDerivWithin n f s) (iteratedDeriv n f) s := by
  unfold iteratedDerivWithin iteratedDeriv
  intro x hx
  simp_rw [iteratedFDerivWithin_of_isOpen (ùïú := ùïú) (F := F) (E := ùïú) (f := f) n hs hx]


theorem exp_iter_deriv_within (n m : ‚Ñï) :
    EqOn (iteratedDerivWithin n (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * m * s)) {z : ‚ÑÇ | 0 < z.im})
      (fun t => (2 * ‚ÜëœÄ * Complex.I * m) ^ n * Complex.exp (2 * ‚ÜëœÄ * Complex.I * m * t)) {z : ‚ÑÇ | 0 < z.im} :=
  by
  apply EqOn.trans (iteratedDerivWithin_of_isOpen _ _ _ ?_)
  rw [EqOn]
  intro x _
  apply congr_fun (iteratedDeriv_cexp_const_mul ..)
  refine isOpen_lt ?_ ?_
  ¬∑ fun_prop
  ¬∑ fun_prop

lemma upper_half_plane_isOpen :
    IsOpen ‚Ñç' := by
  apply isOpen_lt (by fun_prop) (by fun_prop)


theorem der_iter_eq_der_aux2 (k n : ‚Ñï) (r : ‚Ñç') :
  DifferentiableAt ‚ÑÇ
    (fun z : ‚ÑÇ =>
      iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) ‚Ñç' z) ‚Üër :=
  by
  have hh :
    DifferentiableOn ‚ÑÇ (fun t => (2 * ‚ÜëœÄ * Complex.I * n) ^ k * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * t)) ‚Ñç' := by
    apply Differentiable.differentiableOn;
    apply Differentiable.const_mul
    apply Differentiable.cexp
    apply Differentiable.const_mul
    apply differentiable_id
  apply DifferentiableOn.differentiableAt
  apply DifferentiableOn.congr hh
  intro x hx
  apply exp_iter_deriv_within k n hx
  refine IsOpen.mem_nhds ?_ ?_
  ¬∑ apply isOpen_lt (by fun_prop) (by fun_prop)
  exact r.2


theorem der_iter_eq_der2 (k n : ‚Ñï) (r : ‚Ñç') :
    deriv (iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) ‚Ñç') ‚Üër =
      derivWithin (iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) ‚Ñç') ‚Ñç'
        ‚Üër :=
  by
  simp
  apply symm
  apply DifferentiableAt.derivWithin
  apply der_iter_eq_der_aux2
  apply IsOpen.uniqueDiffOn upper_half_plane_isOpen
  apply r.2

theorem der_iter_eq_der2' (k n : ‚Ñï) (r : ‚Ñç') :
    derivWithin (iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) ‚Ñç') ‚Ñç' ‚Üër =
      iteratedDerivWithin (k + 1) (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) ‚Ñç' ‚Üër :=
  by
  rw [iteratedDerivWithin_succ]

theorem iter_deriv_comp_bound2 (K : Set ‚ÑÇ) (hK1 : K ‚äÜ ‚Ñç') (hK2 : IsCompact K) (k : ‚Ñï) :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù,
      Summable u ‚àß
        ‚àÄ (n : ‚Ñï) (r : K),
        ‚Äñ(derivWithin (iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) ‚Ñç') ‚Ñç' r)‚Äñ ‚â§
            u n := by
  have : CompactSpace K := by
    rw [‚Üê isCompact_univ_iff]
    rw [isCompact_iff_isCompact_univ] at hK2
    apply hK2
  set r : ‚Ñù := ‚ÄñBoundedContinuousFunction.mkOfCompact (cts_exp_two_pi_n K )‚Äñ
  have hr : ‚ÄñBoundedContinuousFunction.mkOfCompact (cts_exp_two_pi_n K )‚Äñ < 1 :=
    by
    rw [BoundedContinuousFunction.norm_lt_iff_of_compact]
    intro x; rw [BoundedContinuousFunction.mkOfCompact_apply]; simp_rw [cts_exp_two_pi_n]
    simp only [ContinuousMap.coe_mk]
    apply exp_upperHalfPlane_lt_one ‚ü®x.1, hK1 x.2‚ü©; linarith
  have hr2 : 0 ‚â§ r := by apply norm_nonneg _
  have hu : Summable fun n : ‚Ñï => ‚Äñ((2 * ‚ÜëœÄ * Complex.I * n) ^ (k + 1) * r ^ n)‚Äñ :=
    by
    have : ‚àÄ (n : ‚Ñï), ((2 * ‚ÜëœÄ)^(k+1))* ‚Äñ((n) ^ (k + 1) * (r ^ n))‚Äñ =
      ‚Äñ((2 * ‚ÜëœÄ * Complex.I * n) ^ (k + 1) * r ^ n)‚Äñ := by
        intro n
        norm_cast
        simp [BoundedContinuousFunction.norm_mkOfCompact, Nat.cast_pow, map_pow,
          abs_norm, map_mul, mul_eq_mul_right_iff]
        norm_cast
        simp only [Nat.cast_pow]
        have hh : |œÄ| = œÄ := by simp [Real.pi_pos.le]
        rw [hh]
        ring
    apply Summable.congr _ this
    rw [summable_mul_left_iff]
    apply summable_norm_pow_mul_geometric_of_norm_lt_one
    convert hr
    rw [norm_norm]
    norm_cast
    apply pow_ne_zero
    apply mul_ne_zero
    linarith
    apply Real.pi_ne_zero
  refine' ‚ü®fun n : ‚Ñï => ‚Äñ((2 * ‚ÜëœÄ * Complex.I * n) ^ (k + 1) * r ^ n)‚Äñ, hu, _‚ü©
  intro n t
  have go := der_iter_eq_der2' k n ‚ü®t.1, hK1 t.2‚ü©
  simp at *
  simp_rw [go]
  have h1 := exp_iter_deriv_within (k + 1) n (hK1 t.2)
  norm_cast at *
  simp at *
  rw [h1]
  simp
  have ineqe : ‚Äñ(Complex.exp (2 * œÄ * Complex.I * n * t))‚Äñ ‚â§ ‚Äñr‚Äñ ^ n :=
    by
    have hw1 :
      ‚Äñ (Complex.exp (2 * œÄ * Complex.I * n * t))‚Äñ =
        ‚Äñ (Complex.exp (2 * œÄ * Complex.I * t))‚Äñ ^ n := by
          norm_cast
          rw [‚Üê Complex.norm_pow];
          congr;
          rw [‚Üê exp_nat_mul];
          ring_nf
    rw [hw1]
    norm_cast
    apply pow_le_pow_left‚ÇÄ
    simp only [norm_nonneg]
    have :=
      BoundedContinuousFunction.norm_coe_le_norm
        (BoundedContinuousFunction.mkOfCompact (cts_exp_two_pi_n K)) t
    rw [norm_norm]
    simpa using this
  apply mul_le_mul
  simp
  simp at ineqe
  convert ineqe
  positivity
  positivity

theorem summable_iter_derv' (k : ‚Ñï) (y : ‚Ñç') :
    Summable fun n : ‚Ñï => (2 * ‚ÜëœÄ * Complex.I * n) ^ k * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * y) :=
  by
  apply Summable.of_norm
  simp only [mem_setOf_eq, Complex.norm_mul, norm_pow, norm_real, Real.norm_eq_abs,
    norm_I, mul_one]
  simp_rw [mul_pow, mul_assoc]
  apply Summable.mul_left
  apply Summable.mul_left
  conv =>
    enter [1]
    ext n
    rw [‚Üê norm_pow]
    rw [‚Üê norm_mul]
    rw [show cexp (2 * (‚ÜëœÄ * (Complex.I * (‚Üën * ‚Üëy)))) = cexp (2 * (‚ÜëœÄ * (Complex.I * (‚Üëy)))) ^ n by
      rw [‚Üê Complex.exp_nsmul]
      congr
      ring]
  apply summable_norm_pow_mul_geometric_of_norm_lt_one
  have := exp_upperHalfPlane_lt_one y
  simp at *
  simp_rw [‚Üê mul_assoc] at *
  exact this

theorem exp_series_ite_deriv_uexp2 (k : ‚Ñï) (x : {z : ‚ÑÇ | 0 < z.im}) :
    iteratedDerivWithin k (fun z => ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) {z : ‚ÑÇ | 0 < z.im} x =
      ‚àë' n : ‚Ñï, iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) {z : ‚ÑÇ | 0 < z.im}  x :=
  by
  induction' k with k IH generalizing x
  simp only [iteratedDerivWithin_zero]
  rw [iteratedDerivWithin_succ]
  have HH :
    derivWithin (iteratedDerivWithin k (fun z => ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) {z : ‚ÑÇ | 0 < z.im}) {z : ‚ÑÇ | 0 < z.im}
        x =
      derivWithin
        (fun z =>
          ‚àë' n : ‚Ñï, iteratedDerivWithin k (fun s : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * s)) {z : ‚ÑÇ | 0 < z.im} z)
        {z : ‚ÑÇ | 0 < z.im} x :=
    by
    apply derivWithin_congr
    intro y hy
    apply IH ‚ü®y, hy‚ü©
    apply IH x
  simp_rw [HH]
  rw [derivWithin_tsum_fun']
  apply tsum_congr
  intro b
  rw [iteratedDerivWithin_succ]
  refine isOpen_lt ?_ ?_
  ¬∑ fun_prop
  ¬∑ fun_prop
  ¬∑ exact x.2
  ¬∑ intro y hy
    apply Summable.congr (summable_iter_derv' k ‚ü®y, hy‚ü©)
    intro b
    apply symm
    apply exp_iter_deriv_within k b hy
  intro K hK1 hK2
  let K2 := Set.image (Set.inclusion hK1) univ
  have hKK2 : IsCompact (Set.image (inclusion hK1) univ) := by
    apply IsCompact.image_of_continuousOn
    ¬∑ exact isCompact_iff_isCompact_univ.mp hK2
    ¬∑ exact continuous_inclusion hK1 |>.continuousOn
  apply iter_deriv_comp_bound2 K hK1 hK2 k
  apply der_iter_eq_der_aux2


theorem exp_series_ite_deriv_uexp'' (k : ‚Ñï) (x : {z : ‚ÑÇ | 0 < z.im}) :
    iteratedDerivWithin k (fun z => ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) {z : ‚ÑÇ | 0 < z.im} x =
      ‚àë' n : ‚Ñï, (2 * ‚ÜëœÄ * Complex.I * n) ^ k * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * x) :=
  by
  rw [exp_series_ite_deriv_uexp2 k x]
  apply tsum_congr
  intro b
  apply exp_iter_deriv_within k b x.2


theorem exp_series_ite_deriv_uexp''' (k : ‚Ñï) :
    EqOn (iteratedDerivWithin k (fun z => ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) ‚Ñç')
      (fun x : ‚ÑÇ => ‚àë' n : ‚Ñï, (2 * ‚ÜëœÄ * Complex.I * n) ^ k * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * x)) ‚Ñç' :=
  by
  intro x hx
  apply exp_series_ite_deriv_uexp'' k ‚ü®x, hx‚ü©

theorem uexp_contDiffOn (k n : ‚Ñï) :
    ContDiffOn ‚ÑÇ k (fun z : ‚ÑÇ => Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) ‚Ñç' :=
  by
  apply ContDiff.contDiffOn
  apply ContDiff.cexp
  apply ContDiff.mul
  apply contDiff_const
  apply contDiff_id



theorem iter_deriv_comp_bound3 (K : Set ‚ÑÇ) (hK1 : K ‚äÜ ‚Ñç') (hK2 : IsCompact K) (k : ‚Ñï) :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù,
      Summable u ‚àß
        ‚àÄ (n : ‚Ñï) (r : K),
          (2 * |œÄ| * n) ^ k * ‚Äñ(Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * r))‚Äñ ‚â§ u n :=
  by
  have : CompactSpace K := by
    rw [‚Üê isCompact_univ_iff]
    rw [isCompact_iff_isCompact_univ] at hK2
    apply hK2
  set r : ‚Ñù := ‚ÄñBoundedContinuousFunction.mkOfCompact (cts_exp_two_pi_n K )‚Äñ
  have hr : ‚ÄñBoundedContinuousFunction.mkOfCompact (cts_exp_two_pi_n K )‚Äñ < 1 :=
    by
    rw [BoundedContinuousFunction.norm_lt_iff_of_compact]
    intro x; rw [BoundedContinuousFunction.mkOfCompact_apply]; simp_rw [cts_exp_two_pi_n]
    simp only [ContinuousMap.coe_mk]
    apply exp_upperHalfPlane_lt_one ‚ü®x.1, hK1 x.2‚ü©; linarith
  have hr2 : 0 ‚â§ r := by apply norm_nonneg _
  have hu : Summable fun n : ‚Ñï => ‚Äñ((2 * ‚ÜëœÄ * Complex.I * n) ^ (k) * r ^ n)‚Äñ :=
    by
    have : ‚àÄ (n : ‚Ñï), ((2 * ‚ÜëœÄ)^(k))* ‚Äñ((n) ^ (k) * (r ^ n))‚Äñ =
      ‚Äñ((2 * ‚ÜëœÄ * Complex.I * n) ^ (k) * r ^ n)‚Äñ := by
        intro n
        norm_cast
        simp [BoundedContinuousFunction.norm_mkOfCompact, Nat.cast_pow, map_pow,
          abs_norm, map_mul, mul_eq_mul_right_iff]
        norm_cast
        simp only [Nat.cast_pow]
        have hh : |œÄ| = œÄ := by simp [Real.pi_pos.le]
        rw [hh]
        ring
    apply Summable.congr _ this
    rw [summable_mul_left_iff]
    apply summable_norm_pow_mul_geometric_of_norm_lt_one
    convert hr
    rw [norm_norm]
    norm_cast
    apply pow_ne_zero
    apply mul_ne_zero
    linarith
    apply Real.pi_ne_zero
  refine' ‚ü®fun n : ‚Ñï => ‚Äñ((2 * ‚ÜëœÄ * Complex.I * n) ^ (k) * r ^ n)‚Äñ, hu, _‚ü©
  intro n t
  simp
  have ineqe : ‚Äñ(Complex.exp (2 * œÄ * Complex.I * n * t))‚Äñ ‚â§ ‚Äñr‚Äñ ^ n :=
    by
    have hw1 :
      ‚Äñ (Complex.exp (2 * œÄ * Complex.I * n * t))‚Äñ =
        ‚Äñ (Complex.exp (2 * œÄ * Complex.I * t))‚Äñ ^ n := by
          norm_cast
          rw [‚Üê Complex.norm_pow];
          congr;
          rw [‚Üê exp_nat_mul];
          ring_nf
    rw [hw1]
    norm_cast
    apply pow_le_pow_left‚ÇÄ
    simp only [norm_nonneg]
    have :=
      BoundedContinuousFunction.norm_coe_le_norm
        (BoundedContinuousFunction.mkOfCompact (cts_exp_two_pi_n K)) t
    rw [norm_norm]
    simpa using this
  apply mul_le_mul
  simp
  simp at ineqe
  convert ineqe
  positivity
  positivity


theorem tsum_uexp_contDiffOn (k : ‚Ñï) :
    ContDiffOn ‚ÑÇ k (fun z : ‚ÑÇ => ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) ‚Ñç' :=
  by
  apply contDiffOn_of_differentiableOn_deriv
  intro m _
  apply DifferentiableOn.congr _ (exp_series_ite_deriv_uexp''' m)
  intro x hx
  apply HasDerivWithinAt.differentiableWithinAt
  apply hasDerivWithinAt_tsum_fun _ upper_half_plane_isOpen
  apply hx
  intro y hy
  apply summable_iter_derv' m ‚ü®y, hy‚ü©
  intro K hK1 hK2
  have := iter_deriv_comp_bound3 K hK1 hK2 (m + 1)
  obtain ‚ü®u, hu, hu2‚ü© := this
  refine' ‚ü®u, hu, _‚ü©
  intro n r
  have HU2 := hu2 n r
  simp
  apply le_trans _ HU2
  apply le_of_eq
  norm_cast
  simp
  rw [derivWithin_mul]
  rw [derivWithin_cexp ]
  rw [derivWithin_const_mul]
  simp
  have hr : derivWithin (fun y ‚Ü¶ y) ‚Ñç' ‚Üër = 1 := by
    apply derivWithin_id
    apply IsOpen.uniqueDiffOn upper_half_plane_isOpen
    aesop
  rw [hr]
  simp
  ring
  fun_prop
  fun_prop
  apply IsOpen.uniqueDiffOn upper_half_plane_isOpen
  aesop
  fun_prop
  fun_prop
  intro n r
  fun_prop

theorem iter_der_within_add (k : ‚Ñï+) (x : {z : ‚ÑÇ | 0 < z.im}) :
    iteratedDerivWithin k
        (fun z => ‚ÜëœÄ * Complex.I - (2 * ‚ÜëœÄ * Complex.I) ‚Ä¢
        ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) {z : ‚ÑÇ | 0 < z.im} x =
      -(2 * ‚ÜëœÄ * Complex.I) * ‚àë' n : ‚Ñï, (2 * ‚ÜëœÄ * Complex.I * n) ^ (k : ‚Ñï) *
      Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * x) := by
  rw [iteratedDerivWithin_const_sub (PNat.pos k) ]
  simp
  rw [iteratedDerivWithin_neg' ]
  rw [iteratedDerivWithin_const_mul]
  congr
  have :=  exp_series_ite_deriv_uexp2 k x
  rw [this]
  apply tsum_congr
  intro b
  have := exp_iter_deriv_within k b x.2
  simpa using this
  exact x.2
  refine IsOpen.uniqueDiffOn upper_half_plane_isOpen
  apply tsum_uexp_contDiffOn k
  exact x.2

theorem iter_exp_eqOn (k : ‚Ñï+) :
    EqOn
      (iteratedDerivWithin k
        (fun z => ‚ÜëœÄ * Complex.I - (2 * ‚ÜëœÄ * Complex.I) ‚Ä¢ ‚àë' n : ‚Ñï, Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z)) {z : ‚ÑÇ | 0 < z.im})
      (fun x : ‚ÑÇ =>
        -(2 * ‚ÜëœÄ * Complex.I) * ‚àë' n : ‚Ñï, (2 * ‚ÜëœÄ * Complex.I * n) ^ (k : ‚Ñï) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * x))
      {z : ‚ÑÇ | 0 < z.im} :=
  by
  intro z hz
  apply iter_der_within_add k ‚ü®z, hz‚ü©

theorem pos_sum_eq (k : ‚Ñï) (hk : 0 < k) :
    (fun x : ‚ÑÇ =>
        -(2 * ‚ÜëœÄ * Complex.I) * ‚àë' n : ‚Ñï, (2 * ‚ÜëœÄ * Complex.I * n) ^ (k : ‚Ñï) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * x)) =
      fun x : ‚ÑÇ =>
      -(2 * ‚ÜëœÄ * Complex.I) * ‚àë' n : ‚Ñï+, (2 * ‚ÜëœÄ * Complex.I * n) ^ (k : ‚Ñï) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * x) := by
  ext1 x
  simp
  left
  apply symm
  rw [‚Üê tsum_pnat_eq_tsum_succ4]
  simp
  exact Nat.ne_zero_of_lt hk

theorem q_exp_iden'' (k : ‚Ñï) (hk : 2 ‚â§ k) :
    EqOn (fun z : ‚ÑÇ => (-1 : ‚ÑÇ) ^ (k - 1) * (k - 1)! * ‚àë' d : ‚Ñ§, 1 / ((z : ‚ÑÇ) + d) ^ k)
      (fun z : ‚ÑÇ =>
        -(2 * ‚ÜëœÄ * Complex.I) * ‚àë' n : ‚Ñï+, (2 * ‚ÜëœÄ * Complex.I * n) ^ ((k - 1) : ‚Ñï) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * n * z))
      {z : ‚ÑÇ | 0 < z.im} :=
  by
  have := (aux_iter_der_tsum_eqOn k hk).symm
  apply EqOn.trans this
  have hkpos : 0 < k - 1 := by
    apply Nat.sub_pos_of_lt
    linarith
  have h2 := (iter_exp_eqOn (‚ü®k - 1, hkpos‚ü© : ‚Ñï+)).symm
  simp  [one_div,  Subtype.coe_mk, neg_mul, Algebra.id.smul_eq_mul] at *
  have h3 := pos_sum_eq (k - 1) hkpos
  simp at h3
  rw [h3] at h2
  apply EqOn.symm
  apply EqOn.trans h2
  apply iteratedDerivWithin_congr
  intro z hz
  simp
  have := EisensteinSeries_Identity ‚ü®z, hz‚ü©
  simp at *
  rw [this]
  congr
  ext n
  rw [‚Üê Complex.exp_nsmul]
  congr
  ring

theorem q_exp_iden (k : ‚Ñï) (hk : 2 ‚â§ k) (z : ‚Ñç) :
    ‚àë' d : ‚Ñ§, 1 / ((z : ‚ÑÇ) + d) ^ k =
      (-2 * ‚ÜëœÄ * Complex.I) ^ k / (k - 1)! * ‚àë' n : ‚Ñï+, n ^ ((k - 1) ) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * n) :=
  by
  have := q_exp_iden'' k hk z.2
  have hkk : 1 ‚â§ (k: ‚Ñ§) := by linarith
  simp [one_div, neg_mul] at *
  have hk2 : (-1 : ‚ÑÇ) ^ ((k - 1) ) * (k - 1)! ‚â† 0 := by
    simp only [ne_eq, mul_eq_zero, pow_eq_zero_iff', neg_eq_zero, one_ne_zero, false_and,
      Nat.cast_eq_zero, Nat.factorial_ne_zero, or_self, not_false_eq_true]
  rw [‚Üê mul_right_inj' hk2]
  simp only [UpperHalfPlane.coe]
  rw [this]
  have h3 : (-1) ^ ((k - 1) ) * ‚Üë(k - 1)! * ((-(2 * ‚ÜëœÄ * Complex.I)) ^ k / ‚Üë(k - 1)!) = -(2 * ‚ÜëœÄ * Complex.I) ^ k :=
    by
    rw [mul_div]; rw [div_eq_mul_one_div]; rw [div_eq_inv_mul]; simp_rw [‚Üê mul_assoc];
    simp
    have hj :  (-1) ^ (‚Üëk - 1) * ‚Üë(k - 1)! * (-(2 * ‚ÜëœÄ * Complex.I)) ^ (k : ‚Ñï) * (‚Üë(k - 1)! : ‚ÑÇ)‚Åª¬π =
       (-1) ^ (‚Üëk - 1) * (-(2 * ‚ÜëœÄ * Complex.I)) ^ (k : ‚Ñï) * (‚Üë(k - 1)!  * (‚Üë(k - 1)!)‚Åª¬π) := by ring
    rw [hj]
    have h2 : (‚Üë(k - 1)! : ‚ÑÇ) * (‚Üë(k - 1)!)‚Åª¬π = 1 := by
      rw [mul_inv_cancel‚ÇÄ]
      norm_cast
      apply Nat.factorial_ne_zero
    rw [h2]
    simp
    rw [mul_comm]
    rw [neg_pow]
    rw [mul_comm, ‚Üêmul_assoc]
    rw [‚Üêpow_add]
    rw [Odd.neg_one_pow]
    ring
    have hkk : (k - 1) + k = 2 * k - 1 :=
        by
        rw [add_comm]
        rw [‚Üê Nat.add_sub_assoc]
        rw [two_mul]
        linarith
    rw [hkk]
    apply Nat.Even.sub_odd
    nlinarith
    simp
    exact odd_one
  rw [‚Üê mul_assoc]
  norm_cast at *
  simp at *
  rw [h3]
  have hee :
    ‚àë' n : ‚Ñï+, (2 * ‚ÜëœÄ * Complex.I * ((n : ‚Ñï) : ‚ÑÇ)) ^ ((k - 1) : ‚Ñï) * exp (2 * ‚ÜëœÄ * Complex.I * ((n : ‚Ñï) : ‚ÑÇ) * ‚Üëz) =
      (2 * ‚ÜëœÄ * Complex.I) ^ (k - 1) * ‚àë' n : ‚Ñï+, n ^ (k - 1) * exp (2 * ‚ÜëœÄ * Complex.I * ‚Üëz * n) :=
    by
    rw [‚Üê tsum_mul_left]
    apply tsum_congr
    intro b
    rw [‚Üê mul_assoc]
    ring_nf
  simp [UpperHalfPlane.coe] at *
  rw [hee]
  rw [‚Üê mul_assoc]
  have he2 : 2 * ‚ÜëœÄ * Complex.I * (2 * ‚ÜëœÄ * Complex.I) ^ (k - 1) = (2 * ‚ÜëœÄ * Complex.I) ^ k :=
    by
    have hke : k = 1 + (k - 1) := by
      apply symm; apply Nat.add_sub_of_le
      linarith
    nth_rw 2 [hke]
    norm_cast
    rw [pow_add]
    simp
  rw [he2]

theorem q_exp_iden_2 (k : ‚Ñï) (hk : 3 ‚â§ k) (hk2 : Even k) (z : ‚Ñç) :
    ‚àë' x : ‚Ñ§ √ó ‚Ñ§, 1 / ((x.1 : ‚ÑÇ) * z + x.2) ^ k =
      2 * (riemannZeta (k)) + 2 * ‚àë' c : ‚Ñï+, ‚àë' d : ‚Ñ§, 1 / (c * (z : ‚ÑÇ) + d) ^ k :=
  by
  have hkk : 1 < (k ) := by
    linarith
  rw [tsum_prod, sum_int_even]
  ¬∑ simp only [Int.cast_zero, zero_mul, zero_add, one_div, Int.cast_natCast, add_left_inj]
    rw [sum_int_even]
    simp  [algebraMap.coe_zero, Int.cast_ofNat, one_div]
    have h0 : ((0 : ‚ÑÇ) ^ k)‚Åª¬π = 0 := by simp; omega
    have h00 : ((0 ^ k : ‚Ñï) : ‚Ñù)‚Åª¬π = 0 := by simp; omega
    norm_cast at *
    rw [h0]
    simp  [zero_add, mul_eq_mul_left_iff,  one_ne_zero]
    norm_cast
    simp only [PNat.pow_coe, Nat.cast_pow]
    rw [zeta_nat_eq_tsum_of_gt_one hkk, ‚Üê tsum_pnat_eq_tsum_succ4]
    simp only [CharP.cast_eq_zero, one_div, right_eq_add, inv_eq_zero, pow_eq_zero_iff', ne_eq,
      true_and]
    exact Nat.ne_zero_of_lt hk
    intro n
    simp only [Int.cast_neg, inv_inj]
    rw [Even.neg_pow hk2]
    have := (Complex.summable_one_div_nat_cpow  (p := k)).mpr (by simp [hkk])
    simp only [cpow_ofNat, one_div, re_ofNat, Nat.one_lt_ofNat, iff_true] at *
    norm_cast at *
    apply  Summable.of_nat_of_neg_add_one
    apply this.congr
    intro b
    simp
    rw [‚Üê summable_nat_add_iff 1] at this
    apply this.congr
    intro b
    congr
    rw [Even.neg_pow hk2]
    simp only [Nat.cast_pow, Nat.cast_add, Nat.cast_one, Int.cast_pow, Int.cast_add,
      Int.cast_natCast, Int.cast_one]
  ¬∑ intro n
    simp only [one_div, Int.cast_neg, neg_mul]
    apply symm
    rw [int_sum_neg]
    congr
    funext d
    simp only [Int.cast_neg, inv_inj]
    ring_nf
    have := Even.neg_pow hk2 (n* (z : ‚ÑÇ)  + d)
    rw [‚Üêthis]
    ring
  ¬∑ have hkz : 3 ‚â§ (k : ‚Ñ§) := by linarith
    have:= Summable.prod  (f := fun x : ‚Ñ§ √ó ‚Ñ§ => 1 / ((x.1 : ‚ÑÇ) * z + x.2) ^ k) ?_
    apply this
    rw [‚Üê (piFinTwoEquiv fun _ => ‚Ñ§).summable_iff]
    apply Summable.of_norm
    apply (EisensteinSeries.summable_norm_eisSummand hkz z).congr
    intro v
    simp_rw [eisSummand]
    simp only [Fin.isValue, zpow_neg, zpow_natCast, norm_inv, norm_pow, UpperHalfPlane.coe, one_div,
      piFinTwoEquiv_apply, comp_apply]
  ¬∑ have hkz : 3 ‚â§ (k : ‚Ñ§) := by linarith
    rw [‚Üê (piFinTwoEquiv fun _ => ‚Ñ§).summable_iff]
    apply Summable.of_norm
    apply (EisensteinSeries.summable_norm_eisSummand hkz z).congr
    intro v
    simp_rw [eisSummand]
    simp only [Fin.isValue, zpow_neg, zpow_natCast, norm_inv, norm_pow, UpperHalfPlane.coe, one_div,
      piFinTwoEquiv_apply, comp_apply]

lemma EQ0 (k : ‚Ñï) (z : ‚Ñç) : ‚àë' (x : Fin 2 ‚Üí ‚Ñ§),
    1 / (x 0 * (z : ‚ÑÇ) + x 1) ^ ‚Üëk = ‚àë' x : ‚Ñ§ √ó ‚Ñ§, 1 / ((x.1 : ‚ÑÇ) * z + x.2) ^ k := by
  rw [‚Üê (piFinTwoEquiv fun _ => ‚Ñ§).tsum_eq]
  apply tsum_congr
  intro x
  simp

def mapdiv (n : ‚Ñï+) : Nat.divisorsAntidiagonal n ‚Üí ‚Ñï+ √ó ‚Ñï+ :=
  by
  intro x
  have h11 := Nat.fst_mem_divisors_of_mem_antidiagonal x.2
  have h111 := Nat.pos_of_mem_divisors h11
  have h22 := Nat.snd_mem_divisors_of_mem_antidiagonal x.2
  have h222 := Nat.pos_of_mem_divisors h22
  set n1 : ‚Ñï+ := ‚ü®x.1.1, h111‚ü©
  set n2 : ‚Ñï+ := ‚ü®x.1.2, h222‚ü©
  use n1
  use n2
  exact h222

def sigmaAntidiagonalEquivProd : (Œ£ n : ‚Ñï+, Nat.divisorsAntidiagonal n) ‚âÉ ‚Ñï+ √ó ‚Ñï+
    where
  toFun x := mapdiv x.1 x.2
  invFun x :=
    ‚ü®‚ü®x.1.1 * x.2.1, by apply mul_pos x.1.2 x.2.2‚ü©, ‚ü®x.1, x.2‚ü©, by
      rw [Nat.mem_divisorsAntidiagonal]; simp; constructor; rfl; constructor;
        linarith [x.1.2]; linarith [x.2.2] ‚ü©
  left_inv := by
    rintro ‚ü®n, ‚ü®k, l‚ü©, h‚ü©
    rw [Nat.mem_divisorsAntidiagonal] at h
    simp_rw [mapdiv]
    simp only [h, PNat.mk_coe, eq_self_iff_true, Subtype.coe_eta]
    ext
    simp at *
    simp_rw [h]
    norm_cast
    simp only
    simp only
  right_inv := by
    rintro ‚ü®n, ‚ü®k, l‚ü©, h‚ü©
    simp_rw [mapdiv]
    exfalso

    simp at *
    simp_rw [mapdiv]
    simp [eq_self_iff_true, Subtype.coe_eta]
    norm_cast

theorem sigma_eq_sum_div' (k n : ‚Ñï) : sigma k n = ‚àë d : ‚Ñï in Nat.divisors n, (n / d) ^ k :=
  by
  simp [sigma]
  rw [‚Üê Nat.sum_div_divisors]

theorem aux_inequality_two (z : ‚Ñç) (k : ‚Ñï) (n : Œ£ x : ‚Ñï+, Nat.divisorsAntidiagonal x) :
    ‚Äñ(n.2.1.1 : ‚ÑÇ) ^ k * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * n.2.1.1 * n.2.1.2)‚Äñ ‚â§
      Complex.abs (2 * n.1 ^ (k + 1) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * n.1)) :=
  by
  sorry
/-   simp
  have hn := n.2.2
  simp [Nat.mem_divisorsAntidiagonal,  PNat.ne_zero, not_false_iff] at *
  norm_cast
  simp_rw [‚Üê hn]
  have gt : ‚àÄ a b : ‚Ñï, ((a * b : ‚Ñï) : ‚ÑÇ) = (a : ‚ÑÇ) * (b : ‚ÑÇ) := Nat.cast_mul
  rw [gt]
  rw [‚Üê mul_assoc]
  simp  [Nat.cast_pow, ofReal_mul, PNat.pow_coe, Nat.cast_mul, algebraMap.coe_one]
  rw [mul_le_mul_right _]
  have J := Nat.fst_mem_divisors_of_mem_antidiagonal n.2.2
  simp only [Nat.mem_divisors, Ne.def, PNat.ne_zero, not_false_iff,
    and_true_iff] at J
  have J2 := Nat.le_of_dvd ?_ J
  norm_cast
  apply aux_inequality_one
  apply n.1.2
  exact J2
  apply n.1.2
  simp only [AbsoluteValue.pos_iff, Ne.def]
  apply Complex.exp_ne_zero -/

theorem summable1 {k : ‚Ñï} (z : ‚Ñç) :
    Summable fun p : Œ£ b : ‚Ñï+, ‚Ü•(Nat.divisorsAntidiagonal b) =>
      ((sigmaAntidiagonalEquivProd p).fst : ‚ÑÇ) ^ k *
        exp
          (2 * ‚ÜëœÄ * Complex.I * ‚Üëz * (sigmaAntidiagonalEquivProd p).fst *
            (sigmaAntidiagonalEquivProd p).snd) :=
  by
  sorry
/-   have := Summable.of_norm_bounded _ ?_ (aux_inequality_two z k)
  apply this
  rw [summable_sigma_of_nonneg]
  constructor
  apply fun n => (hasSum_fintype _).summable
  simp only [ AbsoluteValue.map_mul, Complex.abs_two, Complex.abs_pow, abs_natCast]
  apply Summable.of_nonneg_of_le _ _ (@summable_pow_mul_exp (k + 2) z)
  intro x
  rw [tsum_fintype]
  simp only [Finset.univ_eq_attach, Finset.sum_const, Finset.card_attach, nsmul_eq_mul]
  norm_cast
  apply mul_nonneg
  exact (Nat.divisorsAntidiagonal x).card.cast_nonneg
  apply mul_nonneg
  simp [Nat.cast_mul, algebraMap.coe_one, mul_nonneg_iff_of_pos_right, Nat.cast_pos,
    PNat.pos, zero_le_bit0, zero_le_one]
  apply Complex.abs.nonneg
  intro b
  rw [tsum_fintype]
  simp only [Finset.univ_eq_attach, Finset.sum_const, Finset.card_attach, nsmul_eq_mul,
    AbsoluteValue.map_mul, Complex.abs_two, Complex.abs_pow, abs_natCast]
  have hk :
    2 * (b : ‚Ñù) ^ (k + 2 + 1) * Complex.abs (exp (2 * ‚ÜëœÄ * I * ‚Üëz * b)) =
      b ^ 2 * (2 * b ^ (k + 1) * Complex.abs (exp (2 * ‚ÜëœÄ * I * ‚Üëz * b))) :=
    by
    norm_cast
    simp
    ring
  norm_cast at *
  simp at *
  rw [hk]
  have ht := anti_diag_card_le b
  refine' mul_le_mul _ _ _ _
  norm_cast
  simp
  simp
  nlinarith
  intro x
  apply Complex.abs.nonneg -/

theorem sum_sigma_fn_eq {k : ‚Ñï} (z : ‚Ñç) :
    ‚àë' c : ‚Ñï+ √ó ‚Ñï+, (c.1 ^ k : ‚ÑÇ) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * c.1 * c.2) =
      ‚àë' e : ‚Ñï+,
        ‚àë x : Nat.divisorsAntidiagonal e,
          x.1.1 ^ k * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * x.1.1 * x.1.2) :=
  by
  rw [‚Üê sigmaAntidiagonalEquivProd.tsum_eq]
  rw [tsum_sigma']
  congr
  funext
  rw [tsum_fintype]
  congr
  apply fun n => (hasSum_fintype _).summable
  apply summable1

theorem tsum_sigma_eqn2 {k : ‚Ñï} (z : ‚Ñç) :
    ‚àë' (c : Fin 2 ‚Üí ‚Ñï+), (c 0 ^ k : ‚ÑÇ) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * c 0 * c 1) =
      ‚àë' e : ‚Ñï+, sigma k e * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * e) := by
  rw [‚Üê (piFinTwoEquiv fun _ => ‚Ñï+).symm.tsum_eq]
  rw [‚Üê sigmaAntidiagonalEquivProd.tsum_eq]
  simp [sigmaAntidiagonalEquivProd, mapdiv]
  simp_rw [sigma_eq_sum_div']
  simp
  rw [tsum_sigma ]
  apply tsum_congr
  intro n
  rw [tsum_fintype]
  simp
  have := @Nat.sum_divisorsAntidiagonal' ‚ÑÇ _ (fun (x : ‚Ñï) => fun (y : ‚Ñï) =>
    (x : ‚ÑÇ) ^ (k : ‚Ñï) * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * x * y)) n
  simp at this

  sorry
/-   simp_rw [sigma_eq_sum_div',sum_sigma_fn_eq z]
  apply tsum_congr
  intro n
  have :=
    @Nat.sum_divisorsAntidiagonal' ‚ÑÇ _ (fun (x : ‚Ñï) => fun (y : ‚Ñï) =>
      (x : ‚ÑÇ) ^ (k : ‚Ñï) * Complex.exp (2 * ‚ÜëœÄ * I * z * x * y)) n
  simp only [Finset.univ_eq_attach, cpow_nat_cast, EisensteinSeries.uhc, Nat.cast_sum, Nat.cast_pow,
    Nat.isUnit_iff] at *
  simp_rw [mul_assoc] at *
  norm_cast at *
  simp at *
  have dma := div_mul_aux k z n
  simp only [Nat.isUnit_iff, cpow_nat_cast, EisensteinSeries.uhc] at dma
  rw [dma] at this
  have hr :
    (‚àë x : ‚Ñï in (n : ‚Ñï).divisors, ‚Üë(‚Üën / x) ^ k) * exp (2 * (‚ÜëœÄ * (I * (‚Üëz * ‚Üën)))) =
      ‚àë x : ‚Ñï in (n : ‚Ñï).divisors, ‚Üë(‚Üën / x) ^ k * exp (2 * (‚ÜëœÄ * (I * (‚Üëz * (n : ‚Ñï))))) :=
    by
    simp
    apply Finset.sum_mul
  simp at *
  rw [hr, ‚Üê this, ‚Üê(sumaux _)]
  simp only [Finset.univ_eq_attach] -/

lemma EQ1 (k : ‚Ñï) (hk : 3 ‚â§ (k : ‚Ñ§)) (hk2 : Even k) (z : ‚Ñç) : ‚àë' (x : Fin 2 ‚Üí ‚Ñ§),
    1 / (x 0 * (z : ‚ÑÇ) + x 1) ^ ‚Üëk = 2 * riemannZeta ‚Üëk +
    2 * ((-2 * ‚ÜëœÄ * Complex.I) ^ k / ‚Üë(k - 1)!) *
     ‚àë' (n : ‚Ñï+), ‚Üë((œÉ (k - 1)) ‚Üën) * cexp (2 * ‚ÜëœÄ * Complex.I * ‚Üëz * ‚Üë‚Üën) := by

    sorry

lemma EQ22 (k : ‚Ñï) (hk : 3 ‚â§ (k : ‚Ñ§)) (z : ‚Ñç) :
    ‚àë' (x : Fin 2 ‚Üí ‚Ñ§), eisSummand k x z =
    (riemannZeta (k)) * ‚àë' (c : gammaSet 1 0), eisSummand k c z := by
  rw [‚Üê GammaSet_one_Equiv.symm.tsum_eq]
  have hk1 : 1 < k := by omega
  have hr := zeta_nat_eq_tsum_of_gt_one hk1
  rw [tsum_sigma, GammaSet_one_Equiv, hr, tsum_mul_tsum_of_summable_norm (by simp [hk1])
    (by apply(EisensteinSeries.summable_norm_eisSummand hk z).subtype)  ]
  simp
  rw [tsum_prod' ]
  apply tsum_congr
  intro b
  by_cases hb : b = 0
  rw [hb]
  simp only [CharP.cast_eq_zero]
  conv =>
    enter [2,1]
    ext c
    rw [show ((0 : ‚ÑÇ)^ k)‚Åª¬π = 0 by simp; omega]
    simp
  conv =>
    enter [1,1]
    ext c
    rw [gammaSetN_eisSummand k z, show (((0 : ‚Ñï) : ‚ÑÇ)^ (k : ‚Ñ§))‚Åª¬π = 0 by simp; omega]
    simp
  simp
  conv =>
    enter [1,1]
    ext c
    rw [gammaSetN_eisSummand k z]
  have := (gammaSetN_Equiv b hb).tsum_eq (fun v => eisSummand k v z)
  simp_rw [tsum_mul_left]
  simp only [zpow_natCast, mul_eq_mul_left_iff, inv_eq_zero, pow_eq_zero_iff', Nat.cast_eq_zero,
    ne_eq]
  left
  exact this
  have := summable_mul_of_summable_norm (f:= fun (n : ‚Ñï)=> ((n : ‚ÑÇ)^k)‚Åª¬π )
    (g := fun (v : (gammaSet 1 0) ) => eisSummand k v z)
  apply this
  simp only [norm_inv, norm_pow, norm_natCast, Real.summable_nat_pow_inv, hk1]
  apply (EisensteinSeries.summable_norm_eisSummand hk z).subtype
  intro b
  simp only
  apply Summable.mul_left
  apply Summable.of_norm
  apply  (EisensteinSeries.summable_norm_eisSummand hk z).subtype
  have := (GammaSet_one_Equiv.symm.summable_iff ( f := fun v => eisSummand k v z)).mpr ?_
  apply this.congr
  intro b
  simp
  apply (EisensteinSeries.summable_norm_eisSummand hk z).of_norm

lemma EQ2 (k : ‚Ñï) (hk : 3 ‚â§ (k : ‚Ñ§))  (z : ‚Ñç) : ‚àë' (x : Fin 2 ‚Üí ‚Ñ§),
  1 / (x 0 * (z : ‚ÑÇ) + x 1) ^ ‚Üëk = (riemannZeta (k)) * ‚àë' (c : gammaSet 1 0), 1 / ((c.1 0) * (z : ‚ÑÇ) + (c.1 1)) ^ k := by
  have := EQ22 k hk z
  simp_rw [eisSummand] at this
  simp [ UpperHalfPlane.coe] at *
  convert this


/-This result is already proven in the modular forms repo and being PRed (slowly) into mathlib, so
we can use it freely here. -/
lemma E_k_q_expansion (k : ‚Ñï) (hk : 3 ‚â§ (k : ‚Ñ§)) (hk2 : Even k) (z : ‚Ñç) :
    (E k hk) z = 1 +
        (1 / (riemannZeta (k))) * ((-2 * ‚ÜëœÄ * Complex.I) ^ k / (k - 1)!) *
        ‚àë' n : ‚Ñï+, sigma (k - 1) n * Complex.exp (2 * ‚ÜëœÄ * Complex.I * z * n) := by
  rw [E]
  rw [ModularForm.smul_apply]
  have : (eisensteinSeries_MF hk standardcongruencecondition) z =
    (eisensteinSeries_SIF standardcongruencecondition k) z := rfl
  rw [this]
  have := eisensteinSeries_SIF_apply standardcongruencecondition k z
  rw [this, eisensteinSeries, standardcongruencecondition]
  simp
  simp_rw [eisSummand]
  have HE1 := EQ1 k hk hk2 z
  have HE2 := EQ2 k hk z
  have z2 : (riemannZeta (k)) ‚â† 0 := by
    refine riemannZeta_ne_zero_of_one_lt_re ?_
    simp
    omega
  rw [‚Üê inv_mul_eq_iff_eq_mul‚ÇÄ z2 ] at HE2
  simp [UpperHalfPlane.coe] at *
  conv =>
    enter [1,2]
    rw [‚Üê HE2]
  simp_rw [‚Üê mul_assoc]
  rw [HE1, mul_add]
  have : 2‚Åª¬π * (riemannZeta (k))‚Åª¬π * (2 * riemannZeta (k)) = 1 := by
    field_simp
  rw [this]
  ring
